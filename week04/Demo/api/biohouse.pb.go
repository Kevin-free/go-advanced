// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: biohouse.proto

package biohouse

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GameCommand int32

const (
	GameCommand_Nothing                 GameCommand = 0
	GameCommand_ReqPing                 GameCommand = 1000
	GameCommand_ReqLogin                GameCommand = 1001
	GameCommand_ReqLogout               GameCommand = 1002
	GameCommand_PushLogout              GameCommand = 1003
	GameCommand_PushNewMonster          GameCommand = 1004
	GameCommand_PushMoney               GameCommand = 1006
	GameCommand_ReqAttack               GameCommand = 1007
	GameCommand_PushAttack              GameCommand = 1008
	GameCommand_ReqReady                GameCommand = 1009
	GameCommand_ReqMaterial             GameCommand = 1010
	GameCommand_ReqChangeEquipWeaponID  GameCommand = 1011
	GameCommand_ReqChangeHandWeapon     GameCommand = 1012
	GameCommand_PushChangeHandWeapon    GameCommand = 1013
	GameCommand_PushEquipWeapon         GameCommand = 1014
	GameCommand_ReqWeaponReload         GameCommand = 1015
	GameCommand_PushWeaponReload        GameCommand = 1016
	GameCommand_ReqAimMove              GameCommand = 1017
	GameCommand_PushAimMove             GameCommand = 1018
	GameCommand_ReqAttackNull           GameCommand = 1019
	GameCommand_PushAttackNull          GameCommand = 1020
	GameCommand_ReqChangeWeaponPart     GameCommand = 1021
	GameCommand_ReqUpgradeWeaponPart    GameCommand = 1022
	GameCommand_ReqChangeRatio          GameCommand = 1023
	GameCommand_PushChangeRatio         GameCommand = 1024
	GameCommand_ReqEnterTable           GameCommand = 1025
	GameCommand_PushEnterTable          GameCommand = 1026
	GameCommand_ReqLeaveTable           GameCommand = 1027
	GameCommand_PushLeaveTable          GameCommand = 1028
	GameCommand_PushChangeMaterial      GameCommand = 1029
	GameCommand_ReqUseSkill             GameCommand = 1030
	GameCommand_PushUseSkill            GameCommand = 1031
	GameCommand_PushPassLevel           GameCommand = 1032
	GameCommand_PushMonsterAttackPlayer GameCommand = 1033
	GameCommand_PushRecoveryPlayer      GameCommand = 1034
	GameCommand_PushVipLevel            GameCommand = 1035
	GameCommand_PushPropsInfo           GameCommand = 1036
	GameCommand_PushCurLevelInfo        GameCommand = 1037
	GameCommand_ReqHurtPlayer           GameCommand = 1038
	GameCommand_PushHurtPlayer          GameCommand = 1039
	GameCommand_ReqPlayerHPChange       GameCommand = 1040
	GameCommand_PushPlayerHPChange      GameCommand = 1041
)

var GameCommand_name = map[int32]string{
	0:    "Nothing",
	1000: "ReqPing",
	1001: "ReqLogin",
	1002: "ReqLogout",
	1003: "PushLogout",
	1004: "PushNewMonster",
	1006: "PushMoney",
	1007: "ReqAttack",
	1008: "PushAttack",
	1009: "ReqReady",
	1010: "ReqMaterial",
	1011: "ReqChangeEquipWeaponID",
	1012: "ReqChangeHandWeapon",
	1013: "PushChangeHandWeapon",
	1014: "PushEquipWeapon",
	1015: "ReqWeaponReload",
	1016: "PushWeaponReload",
	1017: "ReqAimMove",
	1018: "PushAimMove",
	1019: "ReqAttackNull",
	1020: "PushAttackNull",
	1021: "ReqChangeWeaponPart",
	1022: "ReqUpgradeWeaponPart",
	1023: "ReqChangeRatio",
	1024: "PushChangeRatio",
	1025: "ReqEnterTable",
	1026: "PushEnterTable",
	1027: "ReqLeaveTable",
	1028: "PushLeaveTable",
	1029: "PushChangeMaterial",
	1030: "ReqUseSkill",
	1031: "PushUseSkill",
	1032: "PushPassLevel",
	1033: "PushMonsterAttackPlayer",
	1034: "PushRecoveryPlayer",
	1035: "PushVipLevel",
	1036: "PushPropsInfo",
	1037: "PushCurLevelInfo",
	1038: "ReqHurtPlayer",
	1039: "PushHurtPlayer",
	1040: "ReqPlayerHPChange",
	1041: "PushPlayerHPChange",
}

var GameCommand_value = map[string]int32{
	"Nothing":                 0,
	"ReqPing":                 1000,
	"ReqLogin":                1001,
	"ReqLogout":               1002,
	"PushLogout":              1003,
	"PushNewMonster":          1004,
	"PushMoney":               1006,
	"ReqAttack":               1007,
	"PushAttack":              1008,
	"ReqReady":                1009,
	"ReqMaterial":             1010,
	"ReqChangeEquipWeaponID":  1011,
	"ReqChangeHandWeapon":     1012,
	"PushChangeHandWeapon":    1013,
	"PushEquipWeapon":         1014,
	"ReqWeaponReload":         1015,
	"PushWeaponReload":        1016,
	"ReqAimMove":              1017,
	"PushAimMove":             1018,
	"ReqAttackNull":           1019,
	"PushAttackNull":          1020,
	"ReqChangeWeaponPart":     1021,
	"ReqUpgradeWeaponPart":    1022,
	"ReqChangeRatio":          1023,
	"PushChangeRatio":         1024,
	"ReqEnterTable":           1025,
	"PushEnterTable":          1026,
	"ReqLeaveTable":           1027,
	"PushLeaveTable":          1028,
	"PushChangeMaterial":      1029,
	"ReqUseSkill":             1030,
	"PushUseSkill":            1031,
	"PushPassLevel":           1032,
	"PushMonsterAttackPlayer": 1033,
	"PushRecoveryPlayer":      1034,
	"PushVipLevel":            1035,
	"PushPropsInfo":           1036,
	"PushCurLevelInfo":        1037,
	"ReqHurtPlayer":           1038,
	"PushHurtPlayer":          1039,
	"ReqPlayerHPChange":       1040,
	"PushPlayerHPChange":      1041,
}

func (x GameCommand) Enum() *GameCommand {
	p := new(GameCommand)
	*p = x
	return p
}

func (x GameCommand) String() string {
	return proto.EnumName(GameCommand_name, int32(x))
}

func (x *GameCommand) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GameCommand_value, data, "GameCommand")
	if err != nil {
		return err
	}
	*x = GameCommand(value)
	return nil
}

func (GameCommand) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{0}
}

type BiohouseErrCode int32

const (
	BiohouseErrCode_Success                     BiohouseErrCode = 0
	BiohouseErrCode_PlayerNotExist              BiohouseErrCode = 1000
	BiohouseErrCode_NotInTable                  BiohouseErrCode = 1001
	BiohouseErrCode_EnterRoomIsClosing          BiohouseErrCode = 1002
	BiohouseErrCode_CreatePlayerFailed          BiohouseErrCode = 1003
	BiohouseErrCode_PlayerAlreadyLogin          BiohouseErrCode = 1004
	BiohouseErrCode_InvalidToken                BiohouseErrCode = 1005
	BiohouseErrCode_LoadPropsFailed             BiohouseErrCode = 1006
	BiohouseErrCode_LoadUserInfoFailed          BiohouseErrCode = 1007
	BiohouseErrCode_LoadGameDataFailed          BiohouseErrCode = 1008
	BiohouseErrCode_EnterGameNotifyHall         BiohouseErrCode = 1009
	BiohouseErrCode_EnterTableFailed            BiohouseErrCode = 1010
	BiohouseErrCode_LimitRequireFailed          BiohouseErrCode = 1011
	BiohouseErrCode_EnterLimit                  BiohouseErrCode = 1012
	BiohouseErrCode_TokenVerifyFailed           BiohouseErrCode = 1013
	BiohouseErrCode_TokenError                  BiohouseErrCode = 1014
	BiohouseErrCode_ParameterIsWrong            BiohouseErrCode = 1015
	BiohouseErrCode_MonsterNotExist             BiohouseErrCode = 1016
	BiohouseErrCode_WeaponNotExist              BiohouseErrCode = 1017
	BiohouseErrCode_MonsterHasKilled            BiohouseErrCode = 1018
	BiohouseErrCode_MoneyNotEnough              BiohouseErrCode = 1019
	BiohouseErrCode_PartHasDestroy              BiohouseErrCode = 1020
	BiohouseErrCode_NotHasWeaponPart            BiohouseErrCode = 1021
	BiohouseErrCode_WeaponPartUpgradeMax        BiohouseErrCode = 1022
	BiohouseErrCode_WeaponPartNotFindUpgradeCfg BiohouseErrCode = 1023
	BiohouseErrCode_UpgradeMaterialNotEnough    BiohouseErrCode = 1024
	BiohouseErrCode_UpgradeMaterialNotFindCfg   BiohouseErrCode = 1025
	BiohouseErrCode_HasReady                    BiohouseErrCode = 1026
	BiohouseErrCode_MustEquipOneWeapon          BiohouseErrCode = 1027
	BiohouseErrCode_PartQualityNotGreaterWeapon BiohouseErrCode = 1028
	BiohouseErrCode_HandlNoWeapon               BiohouseErrCode = 1029
	BiohouseErrCode_ZeroQualityUseDefaultRatio  BiohouseErrCode = 1030
	BiohouseErrCode_RatioIllegal                BiohouseErrCode = 1031
	BiohouseErrCode_RatioGreaterWeaponRatio     BiohouseErrCode = 1032
	BiohouseErrCode_WeaponHurtIsZero            BiohouseErrCode = 1033
	BiohouseErrCode_HasEnterTable               BiohouseErrCode = 1034
	BiohouseErrCode_PartsHasDestroy             BiohouseErrCode = 1035
	BiohouseErrCode_NoSkillCanUse               BiohouseErrCode = 1036
	BiohouseErrCode_UseSkillIDIsError           BiohouseErrCode = 1037
	BiohouseErrCode_ModeIsError                 BiohouseErrCode = 1038
	BiohouseErrCode_PlayerHasDied               BiohouseErrCode = 1039
	BiohouseErrCode_EnterTableMoneyNotEnough    BiohouseErrCode = 1040
	BiohouseErrCode_EnterTableWeaponLevelNot    BiohouseErrCode = 1041
	BiohouseErrCode_QPReadGoldFailed            BiohouseErrCode = 1042
	BiohouseErrCode_QPEnterRoomFailed           BiohouseErrCode = 1043
	BiohouseErrCode_VersionIsWrong              BiohouseErrCode = 1044
	BiohouseErrCode_QPBaseUserInfoGetFailed     BiohouseErrCode = 1045
)

var BiohouseErrCode_name = map[int32]string{
	0:    "Success",
	1000: "PlayerNotExist",
	1001: "NotInTable",
	1002: "EnterRoomIsClosing",
	1003: "CreatePlayerFailed",
	1004: "PlayerAlreadyLogin",
	1005: "InvalidToken",
	1006: "LoadPropsFailed",
	1007: "LoadUserInfoFailed",
	1008: "LoadGameDataFailed",
	1009: "EnterGameNotifyHall",
	1010: "EnterTableFailed",
	1011: "LimitRequireFailed",
	1012: "EnterLimit",
	1013: "TokenVerifyFailed",
	1014: "TokenError",
	1015: "ParameterIsWrong",
	1016: "MonsterNotExist",
	1017: "WeaponNotExist",
	1018: "MonsterHasKilled",
	1019: "MoneyNotEnough",
	1020: "PartHasDestroy",
	1021: "NotHasWeaponPart",
	1022: "WeaponPartUpgradeMax",
	1023: "WeaponPartNotFindUpgradeCfg",
	1024: "UpgradeMaterialNotEnough",
	1025: "UpgradeMaterialNotFindCfg",
	1026: "HasReady",
	1027: "MustEquipOneWeapon",
	1028: "PartQualityNotGreaterWeapon",
	1029: "HandlNoWeapon",
	1030: "ZeroQualityUseDefaultRatio",
	1031: "RatioIllegal",
	1032: "RatioGreaterWeaponRatio",
	1033: "WeaponHurtIsZero",
	1034: "HasEnterTable",
	1035: "PartsHasDestroy",
	1036: "NoSkillCanUse",
	1037: "UseSkillIDIsError",
	1038: "ModeIsError",
	1039: "PlayerHasDied",
	1040: "EnterTableMoneyNotEnough",
	1041: "EnterTableWeaponLevelNot",
	1042: "QPReadGoldFailed",
	1043: "QPEnterRoomFailed",
	1044: "VersionIsWrong",
	1045: "QPBaseUserInfoGetFailed",
}

var BiohouseErrCode_value = map[string]int32{
	"Success":                     0,
	"PlayerNotExist":              1000,
	"NotInTable":                  1001,
	"EnterRoomIsClosing":          1002,
	"CreatePlayerFailed":          1003,
	"PlayerAlreadyLogin":          1004,
	"InvalidToken":                1005,
	"LoadPropsFailed":             1006,
	"LoadUserInfoFailed":          1007,
	"LoadGameDataFailed":          1008,
	"EnterGameNotifyHall":         1009,
	"EnterTableFailed":            1010,
	"LimitRequireFailed":          1011,
	"EnterLimit":                  1012,
	"TokenVerifyFailed":           1013,
	"TokenError":                  1014,
	"ParameterIsWrong":            1015,
	"MonsterNotExist":             1016,
	"WeaponNotExist":              1017,
	"MonsterHasKilled":            1018,
	"MoneyNotEnough":              1019,
	"PartHasDestroy":              1020,
	"NotHasWeaponPart":            1021,
	"WeaponPartUpgradeMax":        1022,
	"WeaponPartNotFindUpgradeCfg": 1023,
	"UpgradeMaterialNotEnough":    1024,
	"UpgradeMaterialNotFindCfg":   1025,
	"HasReady":                    1026,
	"MustEquipOneWeapon":          1027,
	"PartQualityNotGreaterWeapon": 1028,
	"HandlNoWeapon":               1029,
	"ZeroQualityUseDefaultRatio":  1030,
	"RatioIllegal":                1031,
	"RatioGreaterWeaponRatio":     1032,
	"WeaponHurtIsZero":            1033,
	"HasEnterTable":               1034,
	"PartsHasDestroy":             1035,
	"NoSkillCanUse":               1036,
	"UseSkillIDIsError":           1037,
	"ModeIsError":                 1038,
	"PlayerHasDied":               1039,
	"EnterTableMoneyNotEnough":    1040,
	"EnterTableWeaponLevelNot":    1041,
	"QPReadGoldFailed":            1042,
	"QPEnterRoomFailed":           1043,
	"VersionIsWrong":              1044,
	"QPBaseUserInfoGetFailed":     1045,
}

func (x BiohouseErrCode) Enum() *BiohouseErrCode {
	p := new(BiohouseErrCode)
	*p = x
	return p
}

func (x BiohouseErrCode) String() string {
	return proto.EnumName(BiohouseErrCode_name, int32(x))
}

func (x *BiohouseErrCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BiohouseErrCode_value, data, "BiohouseErrCode")
	if err != nil {
		return err
	}
	*x = BiohouseErrCode(value)
	return nil
}

func (BiohouseErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{1}
}

type SkillID int32

const (
	SkillID_BigKill SkillID = 1
	SkillID_KillMax SkillID = 2
)

var SkillID_name = map[int32]string{
	1: "BigKill",
	2: "KillMax",
}

var SkillID_value = map[string]int32{
	"BigKill": 1,
	"KillMax": 2,
}

func (x SkillID) Enum() *SkillID {
	p := new(SkillID)
	*p = x
	return p
}

func (x SkillID) String() string {
	return proto.EnumName(SkillID_name, int32(x))
}

func (x *SkillID) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SkillID_value, data, "SkillID")
	if err != nil {
		return err
	}
	*x = SkillID(value)
	return nil
}

func (SkillID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{2}
}

type MaterialType int32

const (
	MaterialType_Upgrade MaterialType = 1
	MaterialType_Drop    MaterialType = 2
)

var MaterialType_name = map[int32]string{
	1: "Upgrade",
	2: "Drop",
}

var MaterialType_value = map[string]int32{
	"Upgrade": 1,
	"Drop":    2,
}

func (x MaterialType) Enum() *MaterialType {
	p := new(MaterialType)
	*p = x
	return p
}

func (x MaterialType) String() string {
	return proto.EnumName(MaterialType_name, int32(x))
}

func (x *MaterialType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MaterialType_value, data, "MaterialType")
	if err != nil {
		return err
	}
	*x = MaterialType(value)
	return nil
}

func (MaterialType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{3}
}

type CSPing struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSPing) Reset()         { *m = CSPing{} }
func (m *CSPing) String() string { return proto.CompactTextString(m) }
func (*CSPing) ProtoMessage()    {}
func (*CSPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{0}
}
func (m *CSPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSPing.Merge(m, src)
}
func (m *CSPing) XXX_Size() int {
	return m.Size()
}
func (m *CSPing) XXX_DiscardUnknown() {
	xxx_messageInfo_CSPing.DiscardUnknown(m)
}

var xxx_messageInfo_CSPing proto.InternalMessageInfo

type SCPing struct {
	CurSec               *int64   `protobuf:"varint,1,opt,name=CurSec" json:"CurSec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCPing) Reset()         { *m = SCPing{} }
func (m *SCPing) String() string { return proto.CompactTextString(m) }
func (*SCPing) ProtoMessage()    {}
func (*SCPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{1}
}
func (m *SCPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCPing.Merge(m, src)
}
func (m *SCPing) XXX_Size() int {
	return m.Size()
}
func (m *SCPing) XXX_DiscardUnknown() {
	xxx_messageInfo_SCPing.DiscardUnknown(m)
}

var xxx_messageInfo_SCPing proto.InternalMessageInfo

func (m *SCPing) GetCurSec() int64 {
	if m != nil && m.CurSec != nil {
		return *m.CurSec
	}
	return 0
}

//枪械信息
type WeaponInfo struct {
	ID                   *int32   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	EquipPart            *string  `protobuf:"bytes,2,opt,name=EquipPart" json:"EquipPart,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WeaponInfo) Reset()         { *m = WeaponInfo{} }
func (m *WeaponInfo) String() string { return proto.CompactTextString(m) }
func (*WeaponInfo) ProtoMessage()    {}
func (*WeaponInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{2}
}
func (m *WeaponInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeaponInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeaponInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeaponInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeaponInfo.Merge(m, src)
}
func (m *WeaponInfo) XXX_Size() int {
	return m.Size()
}
func (m *WeaponInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WeaponInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WeaponInfo proto.InternalMessageInfo

func (m *WeaponInfo) GetID() int32 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *WeaponInfo) GetEquipPart() string {
	if m != nil && m.EquipPart != nil {
		return *m.EquipPart
	}
	return ""
}

// 登录
type CSLogin struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Token                *string  `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
	Version              *int32   `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
	Mode                 *int32   `protobuf:"varint,4,opt,name=Mode" json:"Mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSLogin) Reset()         { *m = CSLogin{} }
func (m *CSLogin) String() string { return proto.CompactTextString(m) }
func (*CSLogin) ProtoMessage()    {}
func (*CSLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{3}
}
func (m *CSLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSLogin.Merge(m, src)
}
func (m *CSLogin) XXX_Size() int {
	return m.Size()
}
func (m *CSLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_CSLogin.DiscardUnknown(m)
}

var xxx_messageInfo_CSLogin proto.InternalMessageInfo

func (m *CSLogin) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *CSLogin) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *CSLogin) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *CSLogin) GetMode() int32 {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return 0
}

type SCLogin struct {
	Money                *int64        `protobuf:"varint,1,opt,name=Money" json:"Money,omitempty"`
	EquipID              []int32       `protobuf:"varint,2,rep,name=EquipID" json:"EquipID,omitempty"`
	HandID               *int32        `protobuf:"varint,3,opt,name=HandID" json:"HandID,omitempty"`
	Info                 []*WeaponInfo `protobuf:"bytes,4,rep,name=Info" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SCLogin) Reset()         { *m = SCLogin{} }
func (m *SCLogin) String() string { return proto.CompactTextString(m) }
func (*SCLogin) ProtoMessage()    {}
func (*SCLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{4}
}
func (m *SCLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCLogin.Merge(m, src)
}
func (m *SCLogin) XXX_Size() int {
	return m.Size()
}
func (m *SCLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_SCLogin.DiscardUnknown(m)
}

var xxx_messageInfo_SCLogin proto.InternalMessageInfo

func (m *SCLogin) GetMoney() int64 {
	if m != nil && m.Money != nil {
		return *m.Money
	}
	return 0
}

func (m *SCLogin) GetEquipID() []int32 {
	if m != nil {
		return m.EquipID
	}
	return nil
}

func (m *SCLogin) GetHandID() int32 {
	if m != nil && m.HandID != nil {
		return *m.HandID
	}
	return 0
}

func (m *SCLogin) GetInfo() []*WeaponInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type CSLogout struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSLogout) Reset()         { *m = CSLogout{} }
func (m *CSLogout) String() string { return proto.CompactTextString(m) }
func (*CSLogout) ProtoMessage()    {}
func (*CSLogout) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{5}
}
func (m *CSLogout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSLogout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSLogout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSLogout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSLogout.Merge(m, src)
}
func (m *CSLogout) XXX_Size() int {
	return m.Size()
}
func (m *CSLogout) XXX_DiscardUnknown() {
	xxx_messageInfo_CSLogout.DiscardUnknown(m)
}

var xxx_messageInfo_CSLogout proto.InternalMessageInfo

type SCLogout struct {
	LogoutType           *int32   `protobuf:"varint,1,opt,name=LogoutType" json:"LogoutType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCLogout) Reset()         { *m = SCLogout{} }
func (m *SCLogout) String() string { return proto.CompactTextString(m) }
func (*SCLogout) ProtoMessage()    {}
func (*SCLogout) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{6}
}
func (m *SCLogout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCLogout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCLogout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCLogout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCLogout.Merge(m, src)
}
func (m *SCLogout) XXX_Size() int {
	return m.Size()
}
func (m *SCLogout) XXX_DiscardUnknown() {
	xxx_messageInfo_SCLogout.DiscardUnknown(m)
}

var xxx_messageInfo_SCLogout proto.InternalMessageInfo

func (m *SCLogout) GetLogoutType() int32 {
	if m != nil && m.LogoutType != nil {
		return *m.LogoutType
	}
	return 0
}

//桌子中的玩家信息
type TablePlayer struct {
	PlayerID             *int64        `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Money                *int64        `protobuf:"varint,2,opt,name=Money" json:"Money,omitempty"`
	ChairId              *int32        `protobuf:"varint,3,opt,name=ChairId" json:"ChairId,omitempty"`
	VipLevel             *int32        `protobuf:"varint,4,opt,name=VipLevel" json:"VipLevel,omitempty"`
	Background           *int32        `protobuf:"varint,5,opt,name=Background" json:"Background,omitempty"`
	Portrait             *string       `protobuf:"bytes,6,opt,name=Portrait" json:"Portrait,omitempty"`
	Nick                 *string       `protobuf:"bytes,7,opt,name=Nick" json:"Nick,omitempty"`
	HandID               *int32        `protobuf:"varint,8,opt,name=HandID" json:"HandID,omitempty"`
	EquipID              []int32       `protobuf:"varint,9,rep,name=EquipID" json:"EquipID,omitempty"`
	Info                 []*WeaponInfo `protobuf:"bytes,10,rep,name=Info" json:"Info,omitempty"`
	Ratio                *int32        `protobuf:"varint,11,opt,name=Ratio" json:"Ratio,omitempty"`
	Blood                *int32        `protobuf:"varint,12,opt,name=Blood" json:"Blood,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TablePlayer) Reset()         { *m = TablePlayer{} }
func (m *TablePlayer) String() string { return proto.CompactTextString(m) }
func (*TablePlayer) ProtoMessage()    {}
func (*TablePlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{7}
}
func (m *TablePlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TablePlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TablePlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TablePlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TablePlayer.Merge(m, src)
}
func (m *TablePlayer) XXX_Size() int {
	return m.Size()
}
func (m *TablePlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TablePlayer.DiscardUnknown(m)
}

var xxx_messageInfo_TablePlayer proto.InternalMessageInfo

func (m *TablePlayer) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *TablePlayer) GetMoney() int64 {
	if m != nil && m.Money != nil {
		return *m.Money
	}
	return 0
}

func (m *TablePlayer) GetChairId() int32 {
	if m != nil && m.ChairId != nil {
		return *m.ChairId
	}
	return 0
}

func (m *TablePlayer) GetVipLevel() int32 {
	if m != nil && m.VipLevel != nil {
		return *m.VipLevel
	}
	return 0
}

func (m *TablePlayer) GetBackground() int32 {
	if m != nil && m.Background != nil {
		return *m.Background
	}
	return 0
}

func (m *TablePlayer) GetPortrait() string {
	if m != nil && m.Portrait != nil {
		return *m.Portrait
	}
	return ""
}

func (m *TablePlayer) GetNick() string {
	if m != nil && m.Nick != nil {
		return *m.Nick
	}
	return ""
}

func (m *TablePlayer) GetHandID() int32 {
	if m != nil && m.HandID != nil {
		return *m.HandID
	}
	return 0
}

func (m *TablePlayer) GetEquipID() []int32 {
	if m != nil {
		return m.EquipID
	}
	return nil
}

func (m *TablePlayer) GetInfo() []*WeaponInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *TablePlayer) GetRatio() int32 {
	if m != nil && m.Ratio != nil {
		return *m.Ratio
	}
	return 0
}

func (m *TablePlayer) GetBlood() int32 {
	if m != nil && m.Blood != nil {
		return *m.Blood
	}
	return 0
}

//客户端进桌请求
type CSEnterTable struct {
	Mode                 *int32   `protobuf:"varint,1,opt,name=Mode" json:"Mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSEnterTable) Reset()         { *m = CSEnterTable{} }
func (m *CSEnterTable) String() string { return proto.CompactTextString(m) }
func (*CSEnterTable) ProtoMessage()    {}
func (*CSEnterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{8}
}
func (m *CSEnterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSEnterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSEnterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSEnterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSEnterTable.Merge(m, src)
}
func (m *CSEnterTable) XXX_Size() int {
	return m.Size()
}
func (m *CSEnterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CSEnterTable.DiscardUnknown(m)
}

var xxx_messageInfo_CSEnterTable proto.InternalMessageInfo

func (m *CSEnterTable) GetMode() int32 {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return 0
}

//push发送 当是新玩家进桌,push桌中所有玩家信息给新进玩家;当是桌中其他玩家收到此协议,则为新进桌玩家信息 (后面再考虑切后台)
type SCEnterTable struct {
	Info                 []*TablePlayer `protobuf:"bytes,1,rep,name=Info" json:"Info,omitempty"`
	TableID              *int32         `protobuf:"varint,2,opt,name=TableID" json:"TableID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCEnterTable) Reset()         { *m = SCEnterTable{} }
func (m *SCEnterTable) String() string { return proto.CompactTextString(m) }
func (*SCEnterTable) ProtoMessage()    {}
func (*SCEnterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{9}
}
func (m *SCEnterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCEnterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCEnterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCEnterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCEnterTable.Merge(m, src)
}
func (m *SCEnterTable) XXX_Size() int {
	return m.Size()
}
func (m *SCEnterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_SCEnterTable.DiscardUnknown(m)
}

var xxx_messageInfo_SCEnterTable proto.InternalMessageInfo

func (m *SCEnterTable) GetInfo() []*TablePlayer {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *SCEnterTable) GetTableID() int32 {
	if m != nil && m.TableID != nil {
		return *m.TableID
	}
	return 0
}

//客户请求离桌请求
type CSLeaveTable struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSLeaveTable) Reset()         { *m = CSLeaveTable{} }
func (m *CSLeaveTable) String() string { return proto.CompactTextString(m) }
func (*CSLeaveTable) ProtoMessage()    {}
func (*CSLeaveTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{10}
}
func (m *CSLeaveTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSLeaveTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSLeaveTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSLeaveTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSLeaveTable.Merge(m, src)
}
func (m *CSLeaveTable) XXX_Size() int {
	return m.Size()
}
func (m *CSLeaveTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CSLeaveTable.DiscardUnknown(m)
}

var xxx_messageInfo_CSLeaveTable proto.InternalMessageInfo

//push到桌子中其他玩家 有人离桌
type SCLeaveTable struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCLeaveTable) Reset()         { *m = SCLeaveTable{} }
func (m *SCLeaveTable) String() string { return proto.CompactTextString(m) }
func (*SCLeaveTable) ProtoMessage()    {}
func (*SCLeaveTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{11}
}
func (m *SCLeaveTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCLeaveTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCLeaveTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCLeaveTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCLeaveTable.Merge(m, src)
}
func (m *SCLeaveTable) XXX_Size() int {
	return m.Size()
}
func (m *SCLeaveTable) XXX_DiscardUnknown() {
	xxx_messageInfo_SCLeaveTable.DiscardUnknown(m)
}

var xxx_messageInfo_SCLeaveTable proto.InternalMessageInfo

func (m *SCLeaveTable) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

//金币同步
type SCMoney struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Money                *int64   `protobuf:"varint,2,opt,name=Money" json:"Money,omitempty"`
	Type                 *int32   `protobuf:"varint,3,opt,name=Type" json:"Type,omitempty"`
	CreateID             *int32   `protobuf:"varint,4,opt,name=CreateID" json:"CreateID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCMoney) Reset()         { *m = SCMoney{} }
func (m *SCMoney) String() string { return proto.CompactTextString(m) }
func (*SCMoney) ProtoMessage()    {}
func (*SCMoney) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{12}
}
func (m *SCMoney) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCMoney) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCMoney.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCMoney) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCMoney.Merge(m, src)
}
func (m *SCMoney) XXX_Size() int {
	return m.Size()
}
func (m *SCMoney) XXX_DiscardUnknown() {
	xxx_messageInfo_SCMoney.DiscardUnknown(m)
}

var xxx_messageInfo_SCMoney proto.InternalMessageInfo

func (m *SCMoney) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCMoney) GetMoney() int64 {
	if m != nil && m.Money != nil {
		return *m.Money
	}
	return 0
}

func (m *SCMoney) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *SCMoney) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

//杀怪
type CSAttack struct {
	CreateID             *int32   `protobuf:"varint,1,opt,name=CreateID" json:"CreateID,omitempty"`
	PartID               *int32   `protobuf:"varint,2,opt,name=PartID" json:"PartID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSAttack) Reset()         { *m = CSAttack{} }
func (m *CSAttack) String() string { return proto.CompactTextString(m) }
func (*CSAttack) ProtoMessage()    {}
func (*CSAttack) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{13}
}
func (m *CSAttack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSAttack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSAttack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSAttack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSAttack.Merge(m, src)
}
func (m *CSAttack) XXX_Size() int {
	return m.Size()
}
func (m *CSAttack) XXX_DiscardUnknown() {
	xxx_messageInfo_CSAttack.DiscardUnknown(m)
}

var xxx_messageInfo_CSAttack proto.InternalMessageInfo

func (m *CSAttack) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *CSAttack) GetPartID() int32 {
	if m != nil && m.PartID != nil {
		return *m.PartID
	}
	return 0
}

//怪物剩余信息
type BloodLeft struct {
	PartType             *int32   `protobuf:"varint,1,opt,name=PartType" json:"PartType,omitempty"`
	LeftBlood            *int32   `protobuf:"varint,2,opt,name=LeftBlood" json:"LeftBlood,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BloodLeft) Reset()         { *m = BloodLeft{} }
func (m *BloodLeft) String() string { return proto.CompactTextString(m) }
func (*BloodLeft) ProtoMessage()    {}
func (*BloodLeft) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{14}
}
func (m *BloodLeft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BloodLeft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BloodLeft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BloodLeft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BloodLeft.Merge(m, src)
}
func (m *BloodLeft) XXX_Size() int {
	return m.Size()
}
func (m *BloodLeft) XXX_DiscardUnknown() {
	xxx_messageInfo_BloodLeft.DiscardUnknown(m)
}

var xxx_messageInfo_BloodLeft proto.InternalMessageInfo

func (m *BloodLeft) GetPartType() int32 {
	if m != nil && m.PartType != nil {
		return *m.PartType
	}
	return 0
}

func (m *BloodLeft) GetLeftBlood() int32 {
	if m != nil && m.LeftBlood != nil {
		return *m.LeftBlood
	}
	return 0
}

//push给所有玩家玩家, CSAttack回包为空 后面需要给桌子中所有玩家的都是用push
type SCAttack struct {
	PlayerID             *int64     `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	CreateID             *int32     `protobuf:"varint,2,opt,name=CreateID" json:"CreateID,omitempty"`
	Money                *int64     `protobuf:"varint,3,opt,name=Money" json:"Money,omitempty"`
	LeftBlood            *int32     `protobuf:"varint,4,opt,name=LeftBlood" json:"LeftBlood,omitempty"`
	Left                 *BloodLeft `protobuf:"bytes,5,opt,name=Left" json:"Left,omitempty"`
	Clip                 *int32     `protobuf:"varint,6,opt,name=Clip" json:"Clip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SCAttack) Reset()         { *m = SCAttack{} }
func (m *SCAttack) String() string { return proto.CompactTextString(m) }
func (*SCAttack) ProtoMessage()    {}
func (*SCAttack) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{15}
}
func (m *SCAttack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCAttack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCAttack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCAttack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCAttack.Merge(m, src)
}
func (m *SCAttack) XXX_Size() int {
	return m.Size()
}
func (m *SCAttack) XXX_DiscardUnknown() {
	xxx_messageInfo_SCAttack.DiscardUnknown(m)
}

var xxx_messageInfo_SCAttack proto.InternalMessageInfo

func (m *SCAttack) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCAttack) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *SCAttack) GetMoney() int64 {
	if m != nil && m.Money != nil {
		return *m.Money
	}
	return 0
}

func (m *SCAttack) GetLeftBlood() int32 {
	if m != nil && m.LeftBlood != nil {
		return *m.LeftBlood
	}
	return 0
}

func (m *SCAttack) GetLeft() *BloodLeft {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *SCAttack) GetClip() int32 {
	if m != nil && m.Clip != nil {
		return *m.Clip
	}
	return 0
}

//玩家vip等级变化
type SCVipLevel struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	VipLevel             *int32   `protobuf:"varint,2,opt,name=VipLevel" json:"VipLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCVipLevel) Reset()         { *m = SCVipLevel{} }
func (m *SCVipLevel) String() string { return proto.CompactTextString(m) }
func (*SCVipLevel) ProtoMessage()    {}
func (*SCVipLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{16}
}
func (m *SCVipLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCVipLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCVipLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCVipLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCVipLevel.Merge(m, src)
}
func (m *SCVipLevel) XXX_Size() int {
	return m.Size()
}
func (m *SCVipLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_SCVipLevel.DiscardUnknown(m)
}

var xxx_messageInfo_SCVipLevel proto.InternalMessageInfo

func (m *SCVipLevel) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCVipLevel) GetVipLevel() int32 {
	if m != nil && m.VipLevel != nil {
		return *m.VipLevel
	}
	return 0
}

//道具信息
type PropsInfo struct {
	PropsID              *int32   `protobuf:"varint,1,opt,name=PropsID" json:"PropsID,omitempty"`
	PropsNum             *int64   `protobuf:"varint,2,opt,name=PropsNum" json:"PropsNum,omitempty"`
	ChangeNum            *int64   `protobuf:"varint,3,opt,name=ChangeNum" json:"ChangeNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropsInfo) Reset()         { *m = PropsInfo{} }
func (m *PropsInfo) String() string { return proto.CompactTextString(m) }
func (*PropsInfo) ProtoMessage()    {}
func (*PropsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{17}
}
func (m *PropsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropsInfo.Merge(m, src)
}
func (m *PropsInfo) XXX_Size() int {
	return m.Size()
}
func (m *PropsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PropsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PropsInfo proto.InternalMessageInfo

func (m *PropsInfo) GetPropsID() int32 {
	if m != nil && m.PropsID != nil {
		return *m.PropsID
	}
	return 0
}

func (m *PropsInfo) GetPropsNum() int64 {
	if m != nil && m.PropsNum != nil {
		return *m.PropsNum
	}
	return 0
}

func (m *PropsInfo) GetChangeNum() int64 {
	if m != nil && m.ChangeNum != nil {
		return *m.ChangeNum
	}
	return 0
}

//其他道具的推送
type SCPropsInfo struct {
	PlayerID             *int64       `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Info                 []*PropsInfo `protobuf:"bytes,2,rep,name=Info" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SCPropsInfo) Reset()         { *m = SCPropsInfo{} }
func (m *SCPropsInfo) String() string { return proto.CompactTextString(m) }
func (*SCPropsInfo) ProtoMessage()    {}
func (*SCPropsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{18}
}
func (m *SCPropsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCPropsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCPropsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCPropsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCPropsInfo.Merge(m, src)
}
func (m *SCPropsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SCPropsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SCPropsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SCPropsInfo proto.InternalMessageInfo

func (m *SCPropsInfo) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCPropsInfo) GetInfo() []*PropsInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

//技能开始使用
type CSUseSkill struct {
	SkillID              *int32   `protobuf:"varint,1,opt,name=SkillID" json:"SkillID,omitempty"`
	Use                  *bool    `protobuf:"varint,2,opt,name=Use" json:"Use,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSUseSkill) Reset()         { *m = CSUseSkill{} }
func (m *CSUseSkill) String() string { return proto.CompactTextString(m) }
func (*CSUseSkill) ProtoMessage()    {}
func (*CSUseSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{19}
}
func (m *CSUseSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSUseSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSUseSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSUseSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSUseSkill.Merge(m, src)
}
func (m *CSUseSkill) XXX_Size() int {
	return m.Size()
}
func (m *CSUseSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_CSUseSkill.DiscardUnknown(m)
}

var xxx_messageInfo_CSUseSkill proto.InternalMessageInfo

func (m *CSUseSkill) GetSkillID() int32 {
	if m != nil && m.SkillID != nil {
		return *m.SkillID
	}
	return 0
}

func (m *CSUseSkill) GetUse() bool {
	if m != nil && m.Use != nil {
		return *m.Use
	}
	return false
}

//push给同桌所有玩家 包括自己
type SCUseSkill struct {
	SkillID              *int32   `protobuf:"varint,1,opt,name=SkillID" json:"SkillID,omitempty"`
	Use                  *bool    `protobuf:"varint,2,opt,name=Use" json:"Use,omitempty"`
	PlayerID             *int64   `protobuf:"varint,3,opt,name=PlayerID" json:"PlayerID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCUseSkill) Reset()         { *m = SCUseSkill{} }
func (m *SCUseSkill) String() string { return proto.CompactTextString(m) }
func (*SCUseSkill) ProtoMessage()    {}
func (*SCUseSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{20}
}
func (m *SCUseSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCUseSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCUseSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCUseSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCUseSkill.Merge(m, src)
}
func (m *SCUseSkill) XXX_Size() int {
	return m.Size()
}
func (m *SCUseSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_SCUseSkill.DiscardUnknown(m)
}

var xxx_messageInfo_SCUseSkill proto.InternalMessageInfo

func (m *SCUseSkill) GetSkillID() int32 {
	if m != nil && m.SkillID != nil {
		return *m.SkillID
	}
	return 0
}

func (m *SCUseSkill) GetUse() bool {
	if m != nil && m.Use != nil {
		return *m.Use
	}
	return false
}

func (m *SCUseSkill) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

type PointInfo struct {
	X                    *float32 `protobuf:"fixed32,1,opt,name=X" json:"X,omitempty"`
	Y                    *float32 `protobuf:"fixed32,2,opt,name=Y" json:"Y,omitempty"`
	Z                    *float32 `protobuf:"fixed32,3,opt,name=Z" json:"Z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PointInfo) Reset()         { *m = PointInfo{} }
func (m *PointInfo) String() string { return proto.CompactTextString(m) }
func (*PointInfo) ProtoMessage()    {}
func (*PointInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{21}
}
func (m *PointInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointInfo.Merge(m, src)
}
func (m *PointInfo) XXX_Size() int {
	return m.Size()
}
func (m *PointInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PointInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PointInfo proto.InternalMessageInfo

func (m *PointInfo) GetX() float32 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *PointInfo) GetY() float32 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *PointInfo) GetZ() float32 {
	if m != nil && m.Z != nil {
		return *m.Z
	}
	return 0
}

type MonsterInfo struct {
	LineType             *int32       `protobuf:"varint,1,opt,name=LineType" json:"LineType,omitempty"`
	CreateID             *int32       `protobuf:"varint,2,opt,name=CreateID" json:"CreateID,omitempty"`
	MonsterID            *int32       `protobuf:"varint,3,opt,name=MonsterID" json:"MonsterID,omitempty"`
	Point                []*PointInfo `protobuf:"bytes,4,rep,name=Point" json:"Point,omitempty"`
	BeginTime            *int64       `protobuf:"varint,6,opt,name=BeginTime" json:"BeginTime,omitempty"`
	EndTime              *int64       `protobuf:"varint,7,opt,name=EndTime" json:"EndTime,omitempty"`
	Left                 []*BloodLeft `protobuf:"bytes,5,rep,name=Left" json:"Left,omitempty"`
	AIType               *int32       `protobuf:"varint,8,opt,name=AIType" json:"AIType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MonsterInfo) Reset()         { *m = MonsterInfo{} }
func (m *MonsterInfo) String() string { return proto.CompactTextString(m) }
func (*MonsterInfo) ProtoMessage()    {}
func (*MonsterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{22}
}
func (m *MonsterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonsterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonsterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonsterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonsterInfo.Merge(m, src)
}
func (m *MonsterInfo) XXX_Size() int {
	return m.Size()
}
func (m *MonsterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MonsterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MonsterInfo proto.InternalMessageInfo

func (m *MonsterInfo) GetLineType() int32 {
	if m != nil && m.LineType != nil {
		return *m.LineType
	}
	return 0
}

func (m *MonsterInfo) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *MonsterInfo) GetMonsterID() int32 {
	if m != nil && m.MonsterID != nil {
		return *m.MonsterID
	}
	return 0
}

func (m *MonsterInfo) GetPoint() []*PointInfo {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *MonsterInfo) GetBeginTime() int64 {
	if m != nil && m.BeginTime != nil {
		return *m.BeginTime
	}
	return 0
}

func (m *MonsterInfo) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *MonsterInfo) GetLeft() []*BloodLeft {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *MonsterInfo) GetAIType() int32 {
	if m != nil && m.AIType != nil {
		return *m.AIType
	}
	return 0
}

//更新怪物到前端 如果是新进入桌子的玩家 怪物同步也是发送次协议
type SCNewMonster struct {
	Info                 []*MonsterInfo `protobuf:"bytes,1,rep,name=Info" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCNewMonster) Reset()         { *m = SCNewMonster{} }
func (m *SCNewMonster) String() string { return proto.CompactTextString(m) }
func (*SCNewMonster) ProtoMessage()    {}
func (*SCNewMonster) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{23}
}
func (m *SCNewMonster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCNewMonster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCNewMonster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCNewMonster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCNewMonster.Merge(m, src)
}
func (m *SCNewMonster) XXX_Size() int {
	return m.Size()
}
func (m *SCNewMonster) XXX_DiscardUnknown() {
	xxx_messageInfo_SCNewMonster.DiscardUnknown(m)
}

var xxx_messageInfo_SCNewMonster proto.InternalMessageInfo

func (m *SCNewMonster) GetInfo() []*MonsterInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

//材料信息
type MaterialInfo struct {
	ID                   *int32   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Num                  *int32   `protobuf:"varint,2,opt,name=Num" json:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaterialInfo) Reset()         { *m = MaterialInfo{} }
func (m *MaterialInfo) String() string { return proto.CompactTextString(m) }
func (*MaterialInfo) ProtoMessage()    {}
func (*MaterialInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{24}
}
func (m *MaterialInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaterialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaterialInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaterialInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaterialInfo.Merge(m, src)
}
func (m *MaterialInfo) XXX_Size() int {
	return m.Size()
}
func (m *MaterialInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MaterialInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MaterialInfo proto.InternalMessageInfo

func (m *MaterialInfo) GetID() int32 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *MaterialInfo) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

//获取材料信息以及改造某个部位需要消耗的材料数量
type CSMaterial struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSMaterial) Reset()         { *m = CSMaterial{} }
func (m *CSMaterial) String() string { return proto.CompactTextString(m) }
func (*CSMaterial) ProtoMessage()    {}
func (*CSMaterial) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{25}
}
func (m *CSMaterial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSMaterial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSMaterial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSMaterial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSMaterial.Merge(m, src)
}
func (m *CSMaterial) XXX_Size() int {
	return m.Size()
}
func (m *CSMaterial) XXX_DiscardUnknown() {
	xxx_messageInfo_CSMaterial.DiscardUnknown(m)
}

var xxx_messageInfo_CSMaterial proto.InternalMessageInfo

type SCMaterial struct {
	MatInfo              []*MaterialInfo `protobuf:"bytes,1,rep,name=MatInfo" json:"MatInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SCMaterial) Reset()         { *m = SCMaterial{} }
func (m *SCMaterial) String() string { return proto.CompactTextString(m) }
func (*SCMaterial) ProtoMessage()    {}
func (*SCMaterial) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{26}
}
func (m *SCMaterial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCMaterial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCMaterial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCMaterial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCMaterial.Merge(m, src)
}
func (m *SCMaterial) XXX_Size() int {
	return m.Size()
}
func (m *SCMaterial) XXX_DiscardUnknown() {
	xxx_messageInfo_SCMaterial.DiscardUnknown(m)
}

var xxx_messageInfo_SCMaterial proto.InternalMessageInfo

func (m *SCMaterial) GetMatInfo() []*MaterialInfo {
	if m != nil {
		return m.MatInfo
	}
	return nil
}

//消耗或者获得材料 更新变化的材料当前总数量到前端
type SCChangeMaterial struct {
	MatInfo              []*MaterialInfo `protobuf:"bytes,1,rep,name=MatInfo" json:"MatInfo,omitempty"`
	Type                 *MaterialType   `protobuf:"varint,2,opt,name=Type,enum=biohouse.MaterialType" json:"Type,omitempty"`
	PlayerID             *int64          `protobuf:"varint,3,opt,name=PlayerID" json:"PlayerID,omitempty"`
	CreateID             *int32          `protobuf:"varint,4,opt,name=CreateID" json:"CreateID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SCChangeMaterial) Reset()         { *m = SCChangeMaterial{} }
func (m *SCChangeMaterial) String() string { return proto.CompactTextString(m) }
func (*SCChangeMaterial) ProtoMessage()    {}
func (*SCChangeMaterial) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{27}
}
func (m *SCChangeMaterial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCChangeMaterial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCChangeMaterial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCChangeMaterial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCChangeMaterial.Merge(m, src)
}
func (m *SCChangeMaterial) XXX_Size() int {
	return m.Size()
}
func (m *SCChangeMaterial) XXX_DiscardUnknown() {
	xxx_messageInfo_SCChangeMaterial.DiscardUnknown(m)
}

var xxx_messageInfo_SCChangeMaterial proto.InternalMessageInfo

func (m *SCChangeMaterial) GetMatInfo() []*MaterialInfo {
	if m != nil {
		return m.MatInfo
	}
	return nil
}

func (m *SCChangeMaterial) GetType() MaterialType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MaterialType_Upgrade
}

func (m *SCChangeMaterial) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCChangeMaterial) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

//更换身上的武器,装备栏上的3个位置0、1、2都要发送过来
type CSChangeEquipWeaponID struct {
	EquipID              []int32  `protobuf:"varint,1,rep,name=EquipID" json:"EquipID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSChangeEquipWeaponID) Reset()         { *m = CSChangeEquipWeaponID{} }
func (m *CSChangeEquipWeaponID) String() string { return proto.CompactTextString(m) }
func (*CSChangeEquipWeaponID) ProtoMessage()    {}
func (*CSChangeEquipWeaponID) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{28}
}
func (m *CSChangeEquipWeaponID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSChangeEquipWeaponID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSChangeEquipWeaponID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSChangeEquipWeaponID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSChangeEquipWeaponID.Merge(m, src)
}
func (m *CSChangeEquipWeaponID) XXX_Size() int {
	return m.Size()
}
func (m *CSChangeEquipWeaponID) XXX_DiscardUnknown() {
	xxx_messageInfo_CSChangeEquipWeaponID.DiscardUnknown(m)
}

var xxx_messageInfo_CSChangeEquipWeaponID proto.InternalMessageInfo

func (m *CSChangeEquipWeaponID) GetEquipID() []int32 {
	if m != nil {
		return m.EquipID
	}
	return nil
}

type SCChangeEquipWeaponID struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCChangeEquipWeaponID) Reset()         { *m = SCChangeEquipWeaponID{} }
func (m *SCChangeEquipWeaponID) String() string { return proto.CompactTextString(m) }
func (*SCChangeEquipWeaponID) ProtoMessage()    {}
func (*SCChangeEquipWeaponID) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{29}
}
func (m *SCChangeEquipWeaponID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCChangeEquipWeaponID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCChangeEquipWeaponID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCChangeEquipWeaponID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCChangeEquipWeaponID.Merge(m, src)
}
func (m *SCChangeEquipWeaponID) XXX_Size() int {
	return m.Size()
}
func (m *SCChangeEquipWeaponID) XXX_DiscardUnknown() {
	xxx_messageInfo_SCChangeEquipWeaponID.DiscardUnknown(m)
}

var xxx_messageInfo_SCChangeEquipWeaponID proto.InternalMessageInfo

//更换手上使用的是哪个的武器栏位id
type CSChangeHandWeapon struct {
	HandID               *int32   `protobuf:"varint,1,opt,name=HandID" json:"HandID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSChangeHandWeapon) Reset()         { *m = CSChangeHandWeapon{} }
func (m *CSChangeHandWeapon) String() string { return proto.CompactTextString(m) }
func (*CSChangeHandWeapon) ProtoMessage()    {}
func (*CSChangeHandWeapon) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{30}
}
func (m *CSChangeHandWeapon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSChangeHandWeapon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSChangeHandWeapon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSChangeHandWeapon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSChangeHandWeapon.Merge(m, src)
}
func (m *CSChangeHandWeapon) XXX_Size() int {
	return m.Size()
}
func (m *CSChangeHandWeapon) XXX_DiscardUnknown() {
	xxx_messageInfo_CSChangeHandWeapon.DiscardUnknown(m)
}

var xxx_messageInfo_CSChangeHandWeapon proto.InternalMessageInfo

func (m *CSChangeHandWeapon) GetHandID() int32 {
	if m != nil && m.HandID != nil {
		return *m.HandID
	}
	return 0
}

//push到桌子中其他玩家 换了武器 则默认的倍率也会使用当前武器装备的品阶倍率
type SCChangeHandWeapon struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	HandID               *int32   `protobuf:"varint,2,opt,name=HandID" json:"HandID,omitempty"`
	Ratio                *int32   `protobuf:"varint,3,opt,name=Ratio" json:"Ratio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCChangeHandWeapon) Reset()         { *m = SCChangeHandWeapon{} }
func (m *SCChangeHandWeapon) String() string { return proto.CompactTextString(m) }
func (*SCChangeHandWeapon) ProtoMessage()    {}
func (*SCChangeHandWeapon) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{31}
}
func (m *SCChangeHandWeapon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCChangeHandWeapon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCChangeHandWeapon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCChangeHandWeapon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCChangeHandWeapon.Merge(m, src)
}
func (m *SCChangeHandWeapon) XXX_Size() int {
	return m.Size()
}
func (m *SCChangeHandWeapon) XXX_DiscardUnknown() {
	xxx_messageInfo_SCChangeHandWeapon.DiscardUnknown(m)
}

var xxx_messageInfo_SCChangeHandWeapon proto.InternalMessageInfo

func (m *SCChangeHandWeapon) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCChangeHandWeapon) GetHandID() int32 {
	if m != nil && m.HandID != nil {
		return *m.HandID
	}
	return 0
}

func (m *SCChangeHandWeapon) GetRatio() int32 {
	if m != nil && m.Ratio != nil {
		return *m.Ratio
	}
	return 0
}

//更换武器配件 的品阶
type CSChangeWeaponPart struct {
	WeaponID             *int32   `protobuf:"varint,1,opt,name=WeaponID" json:"WeaponID,omitempty"`
	PartID               *int32   `protobuf:"varint,2,opt,name=PartID" json:"PartID,omitempty"`
	Quality              *int32   `protobuf:"varint,3,opt,name=Quality" json:"Quality,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSChangeWeaponPart) Reset()         { *m = CSChangeWeaponPart{} }
func (m *CSChangeWeaponPart) String() string { return proto.CompactTextString(m) }
func (*CSChangeWeaponPart) ProtoMessage()    {}
func (*CSChangeWeaponPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{32}
}
func (m *CSChangeWeaponPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSChangeWeaponPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSChangeWeaponPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSChangeWeaponPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSChangeWeaponPart.Merge(m, src)
}
func (m *CSChangeWeaponPart) XXX_Size() int {
	return m.Size()
}
func (m *CSChangeWeaponPart) XXX_DiscardUnknown() {
	xxx_messageInfo_CSChangeWeaponPart.DiscardUnknown(m)
}

var xxx_messageInfo_CSChangeWeaponPart proto.InternalMessageInfo

func (m *CSChangeWeaponPart) GetWeaponID() int32 {
	if m != nil && m.WeaponID != nil {
		return *m.WeaponID
	}
	return 0
}

func (m *CSChangeWeaponPart) GetPartID() int32 {
	if m != nil && m.PartID != nil {
		return *m.PartID
	}
	return 0
}

func (m *CSChangeWeaponPart) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

type SCChangeWeaponPart struct {
	Info                 *WeaponInfo `protobuf:"bytes,1,opt,name=Info" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SCChangeWeaponPart) Reset()         { *m = SCChangeWeaponPart{} }
func (m *SCChangeWeaponPart) String() string { return proto.CompactTextString(m) }
func (*SCChangeWeaponPart) ProtoMessage()    {}
func (*SCChangeWeaponPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{33}
}
func (m *SCChangeWeaponPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCChangeWeaponPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCChangeWeaponPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCChangeWeaponPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCChangeWeaponPart.Merge(m, src)
}
func (m *SCChangeWeaponPart) XXX_Size() int {
	return m.Size()
}
func (m *SCChangeWeaponPart) XXX_DiscardUnknown() {
	xxx_messageInfo_SCChangeWeaponPart.DiscardUnknown(m)
}

var xxx_messageInfo_SCChangeWeaponPart proto.InternalMessageInfo

func (m *SCChangeWeaponPart) GetInfo() *WeaponInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

//改造武器配件
type CSUpgradeWeaponPart struct {
	WeaponID             *int32   `protobuf:"varint,1,opt,name=WeaponID" json:"WeaponID,omitempty"`
	PartID               *int32   `protobuf:"varint,2,opt,name=PartID" json:"PartID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSUpgradeWeaponPart) Reset()         { *m = CSUpgradeWeaponPart{} }
func (m *CSUpgradeWeaponPart) String() string { return proto.CompactTextString(m) }
func (*CSUpgradeWeaponPart) ProtoMessage()    {}
func (*CSUpgradeWeaponPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{34}
}
func (m *CSUpgradeWeaponPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSUpgradeWeaponPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSUpgradeWeaponPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSUpgradeWeaponPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSUpgradeWeaponPart.Merge(m, src)
}
func (m *CSUpgradeWeaponPart) XXX_Size() int {
	return m.Size()
}
func (m *CSUpgradeWeaponPart) XXX_DiscardUnknown() {
	xxx_messageInfo_CSUpgradeWeaponPart.DiscardUnknown(m)
}

var xxx_messageInfo_CSUpgradeWeaponPart proto.InternalMessageInfo

func (m *CSUpgradeWeaponPart) GetWeaponID() int32 {
	if m != nil && m.WeaponID != nil {
		return *m.WeaponID
	}
	return 0
}

func (m *CSUpgradeWeaponPart) GetPartID() int32 {
	if m != nil && m.PartID != nil {
		return *m.PartID
	}
	return 0
}

type SCUpgradeWeaponPart struct {
	Info                 *WeaponInfo `protobuf:"bytes,1,opt,name=Info" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SCUpgradeWeaponPart) Reset()         { *m = SCUpgradeWeaponPart{} }
func (m *SCUpgradeWeaponPart) String() string { return proto.CompactTextString(m) }
func (*SCUpgradeWeaponPart) ProtoMessage()    {}
func (*SCUpgradeWeaponPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{35}
}
func (m *SCUpgradeWeaponPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCUpgradeWeaponPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCUpgradeWeaponPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCUpgradeWeaponPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCUpgradeWeaponPart.Merge(m, src)
}
func (m *SCUpgradeWeaponPart) XXX_Size() int {
	return m.Size()
}
func (m *SCUpgradeWeaponPart) XXX_DiscardUnknown() {
	xxx_messageInfo_SCUpgradeWeaponPart.DiscardUnknown(m)
}

var xxx_messageInfo_SCUpgradeWeaponPart proto.InternalMessageInfo

func (m *SCUpgradeWeaponPart) GetInfo() *WeaponInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

//要进桌之后才能发送此更换倍率
type CSChangeRatio struct {
	Ratio                *int32   `protobuf:"varint,1,opt,name=Ratio" json:"Ratio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSChangeRatio) Reset()         { *m = CSChangeRatio{} }
func (m *CSChangeRatio) String() string { return proto.CompactTextString(m) }
func (*CSChangeRatio) ProtoMessage()    {}
func (*CSChangeRatio) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{36}
}
func (m *CSChangeRatio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSChangeRatio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSChangeRatio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSChangeRatio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSChangeRatio.Merge(m, src)
}
func (m *CSChangeRatio) XXX_Size() int {
	return m.Size()
}
func (m *CSChangeRatio) XXX_DiscardUnknown() {
	xxx_messageInfo_CSChangeRatio.DiscardUnknown(m)
}

var xxx_messageInfo_CSChangeRatio proto.InternalMessageInfo

func (m *CSChangeRatio) GetRatio() int32 {
	if m != nil && m.Ratio != nil {
		return *m.Ratio
	}
	return 0
}

//push到桌子中其他玩家
type SCChangeRatio struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Ratio                *int32   `protobuf:"varint,2,opt,name=Ratio" json:"Ratio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCChangeRatio) Reset()         { *m = SCChangeRatio{} }
func (m *SCChangeRatio) String() string { return proto.CompactTextString(m) }
func (*SCChangeRatio) ProtoMessage()    {}
func (*SCChangeRatio) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{37}
}
func (m *SCChangeRatio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCChangeRatio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCChangeRatio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCChangeRatio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCChangeRatio.Merge(m, src)
}
func (m *SCChangeRatio) XXX_Size() int {
	return m.Size()
}
func (m *SCChangeRatio) XXX_DiscardUnknown() {
	xxx_messageInfo_SCChangeRatio.DiscardUnknown(m)
}

var xxx_messageInfo_SCChangeRatio proto.InternalMessageInfo

func (m *SCChangeRatio) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCChangeRatio) GetRatio() int32 {
	if m != nil && m.Ratio != nil {
		return *m.Ratio
	}
	return 0
}

//换子弹（推送给同桌,自己不需要回包）
type CSWeaponReload struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSWeaponReload) Reset()         { *m = CSWeaponReload{} }
func (m *CSWeaponReload) String() string { return proto.CompactTextString(m) }
func (*CSWeaponReload) ProtoMessage()    {}
func (*CSWeaponReload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{38}
}
func (m *CSWeaponReload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSWeaponReload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSWeaponReload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSWeaponReload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSWeaponReload.Merge(m, src)
}
func (m *CSWeaponReload) XXX_Size() int {
	return m.Size()
}
func (m *CSWeaponReload) XXX_DiscardUnknown() {
	xxx_messageInfo_CSWeaponReload.DiscardUnknown(m)
}

var xxx_messageInfo_CSWeaponReload proto.InternalMessageInfo

//push给桌子中其他玩家 自己不需要
type SCWeaponReload struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCWeaponReload) Reset()         { *m = SCWeaponReload{} }
func (m *SCWeaponReload) String() string { return proto.CompactTextString(m) }
func (*SCWeaponReload) ProtoMessage()    {}
func (*SCWeaponReload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{39}
}
func (m *SCWeaponReload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCWeaponReload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCWeaponReload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCWeaponReload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCWeaponReload.Merge(m, src)
}
func (m *SCWeaponReload) XXX_Size() int {
	return m.Size()
}
func (m *SCWeaponReload) XXX_DiscardUnknown() {
	xxx_messageInfo_SCWeaponReload.DiscardUnknown(m)
}

var xxx_messageInfo_SCWeaponReload proto.InternalMessageInfo

func (m *SCWeaponReload) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

//准星移动（推送给同桌,自己不需要回包）
type CSAimMove struct {
	Point                *PointInfo `protobuf:"bytes,1,opt,name=Point" json:"Point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CSAimMove) Reset()         { *m = CSAimMove{} }
func (m *CSAimMove) String() string { return proto.CompactTextString(m) }
func (*CSAimMove) ProtoMessage()    {}
func (*CSAimMove) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{40}
}
func (m *CSAimMove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSAimMove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSAimMove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSAimMove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSAimMove.Merge(m, src)
}
func (m *CSAimMove) XXX_Size() int {
	return m.Size()
}
func (m *CSAimMove) XXX_DiscardUnknown() {
	xxx_messageInfo_CSAimMove.DiscardUnknown(m)
}

var xxx_messageInfo_CSAimMove proto.InternalMessageInfo

func (m *CSAimMove) GetPoint() *PointInfo {
	if m != nil {
		return m.Point
	}
	return nil
}

//push给桌子中其他玩家 自己不需要
type SCAimMove struct {
	PlayerID             *int64     `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Point                *PointInfo `protobuf:"bytes,2,opt,name=Point" json:"Point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SCAimMove) Reset()         { *m = SCAimMove{} }
func (m *SCAimMove) String() string { return proto.CompactTextString(m) }
func (*SCAimMove) ProtoMessage()    {}
func (*SCAimMove) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{41}
}
func (m *SCAimMove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCAimMove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCAimMove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCAimMove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCAimMove.Merge(m, src)
}
func (m *SCAimMove) XXX_Size() int {
	return m.Size()
}
func (m *SCAimMove) XXX_DiscardUnknown() {
	xxx_messageInfo_SCAimMove.DiscardUnknown(m)
}

var xxx_messageInfo_SCAimMove proto.InternalMessageInfo

func (m *SCAimMove) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCAimMove) GetPoint() *PointInfo {
	if m != nil {
		return m.Point
	}
	return nil
}

//放空枪，（推送给同桌,自己不需要回包）
type CSAttackNull struct {
	Point                *PointInfo `protobuf:"bytes,1,opt,name=Point" json:"Point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CSAttackNull) Reset()         { *m = CSAttackNull{} }
func (m *CSAttackNull) String() string { return proto.CompactTextString(m) }
func (*CSAttackNull) ProtoMessage()    {}
func (*CSAttackNull) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{42}
}
func (m *CSAttackNull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSAttackNull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSAttackNull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSAttackNull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSAttackNull.Merge(m, src)
}
func (m *CSAttackNull) XXX_Size() int {
	return m.Size()
}
func (m *CSAttackNull) XXX_DiscardUnknown() {
	xxx_messageInfo_CSAttackNull.DiscardUnknown(m)
}

var xxx_messageInfo_CSAttackNull proto.InternalMessageInfo

func (m *CSAttackNull) GetPoint() *PointInfo {
	if m != nil {
		return m.Point
	}
	return nil
}

//push给桌子中其他玩家 自己不需要
type SCAttackNull struct {
	PlayerID             *int64     `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Point                *PointInfo `protobuf:"bytes,2,opt,name=Point" json:"Point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SCAttackNull) Reset()         { *m = SCAttackNull{} }
func (m *SCAttackNull) String() string { return proto.CompactTextString(m) }
func (*SCAttackNull) ProtoMessage()    {}
func (*SCAttackNull) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{43}
}
func (m *SCAttackNull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCAttackNull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCAttackNull.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCAttackNull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCAttackNull.Merge(m, src)
}
func (m *SCAttackNull) XXX_Size() int {
	return m.Size()
}
func (m *SCAttackNull) XXX_DiscardUnknown() {
	xxx_messageInfo_SCAttackNull.DiscardUnknown(m)
}

var xxx_messageInfo_SCAttackNull proto.InternalMessageInfo

func (m *SCAttackNull) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCAttackNull) GetPoint() *PointInfo {
	if m != nil {
		return m.Point
	}
	return nil
}

//通知客户端 创关进入新的节点，或者闯关成功,进入新的地图模式 玩家进桌也会发送次协议
type SCPassLevel struct {
	Success              *bool    `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	NewPass              *bool    `protobuf:"varint,2,opt,name=NewPass" json:"NewPass,omitempty"`
	MapID                *int32   `protobuf:"varint,3,opt,name=MapID" json:"MapID,omitempty"`
	Node                 *int32   `protobuf:"varint,4,opt,name=Node" json:"Node,omitempty"`
	PathID               *int32   `protobuf:"varint,5,opt,name=PathID" json:"PathID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCPassLevel) Reset()         { *m = SCPassLevel{} }
func (m *SCPassLevel) String() string { return proto.CompactTextString(m) }
func (*SCPassLevel) ProtoMessage()    {}
func (*SCPassLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{44}
}
func (m *SCPassLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCPassLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCPassLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCPassLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCPassLevel.Merge(m, src)
}
func (m *SCPassLevel) XXX_Size() int {
	return m.Size()
}
func (m *SCPassLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_SCPassLevel.DiscardUnknown(m)
}

var xxx_messageInfo_SCPassLevel proto.InternalMessageInfo

func (m *SCPassLevel) GetSuccess() bool {
	if m != nil && m.Success != nil {
		return *m.Success
	}
	return false
}

func (m *SCPassLevel) GetNewPass() bool {
	if m != nil && m.NewPass != nil {
		return *m.NewPass
	}
	return false
}

func (m *SCPassLevel) GetMapID() int32 {
	if m != nil && m.MapID != nil {
		return *m.MapID
	}
	return 0
}

func (m *SCPassLevel) GetNode() int32 {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return 0
}

func (m *SCPassLevel) GetPathID() int32 {
	if m != nil && m.PathID != nil {
		return *m.PathID
	}
	return 0
}

type HurtBlood struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Blood                *int32   `protobuf:"varint,2,opt,name=Blood" json:"Blood,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HurtBlood) Reset()         { *m = HurtBlood{} }
func (m *HurtBlood) String() string { return proto.CompactTextString(m) }
func (*HurtBlood) ProtoMessage()    {}
func (*HurtBlood) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{45}
}
func (m *HurtBlood) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HurtBlood) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HurtBlood.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HurtBlood) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HurtBlood.Merge(m, src)
}
func (m *HurtBlood) XXX_Size() int {
	return m.Size()
}
func (m *HurtBlood) XXX_DiscardUnknown() {
	xxx_messageInfo_HurtBlood.DiscardUnknown(m)
}

var xxx_messageInfo_HurtBlood proto.InternalMessageInfo

func (m *HurtBlood) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *HurtBlood) GetBlood() int32 {
	if m != nil && m.Blood != nil {
		return *m.Blood
	}
	return 0
}

//怪物攻击了哪几个玩家 攻击的血量值
type HurtPlayer struct {
	CreateID             *int32       `protobuf:"varint,1,opt,name=CreateID" json:"CreateID,omitempty"`
	Hurt                 []*HurtBlood `protobuf:"bytes,2,rep,name=Hurt" json:"Hurt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HurtPlayer) Reset()         { *m = HurtPlayer{} }
func (m *HurtPlayer) String() string { return proto.CompactTextString(m) }
func (*HurtPlayer) ProtoMessage()    {}
func (*HurtPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{46}
}
func (m *HurtPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HurtPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HurtPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HurtPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HurtPlayer.Merge(m, src)
}
func (m *HurtPlayer) XXX_Size() int {
	return m.Size()
}
func (m *HurtPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_HurtPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_HurtPlayer proto.InternalMessageInfo

func (m *HurtPlayer) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *HurtPlayer) GetHurt() []*HurtBlood {
	if m != nil {
		return m.Hurt
	}
	return nil
}

//玩家的剩余血量情况
type PlayerBlood struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	Blood                *int32   `protobuf:"varint,2,opt,name=Blood" json:"Blood,omitempty"`
	HasDied              *bool    `protobuf:"varint,3,opt,name=HasDied" json:"HasDied,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerBlood) Reset()         { *m = PlayerBlood{} }
func (m *PlayerBlood) String() string { return proto.CompactTextString(m) }
func (*PlayerBlood) ProtoMessage()    {}
func (*PlayerBlood) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{47}
}
func (m *PlayerBlood) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerBlood) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerBlood.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerBlood) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerBlood.Merge(m, src)
}
func (m *PlayerBlood) XXX_Size() int {
	return m.Size()
}
func (m *PlayerBlood) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerBlood.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerBlood proto.InternalMessageInfo

func (m *PlayerBlood) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *PlayerBlood) GetBlood() int32 {
	if m != nil && m.Blood != nil {
		return *m.Blood
	}
	return 0
}

func (m *PlayerBlood) GetHasDied() bool {
	if m != nil && m.HasDied != nil {
		return *m.HasDied
	}
	return false
}

//怪物攻击玩家
type SCMonsterAttackPlayer struct {
	Hp                   []*HurtPlayer  `protobuf:"bytes,1,rep,name=Hp" json:"Hp,omitempty"`
	Left                 []*PlayerBlood `protobuf:"bytes,2,rep,name=Left" json:"Left,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCMonsterAttackPlayer) Reset()         { *m = SCMonsterAttackPlayer{} }
func (m *SCMonsterAttackPlayer) String() string { return proto.CompactTextString(m) }
func (*SCMonsterAttackPlayer) ProtoMessage()    {}
func (*SCMonsterAttackPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{48}
}
func (m *SCMonsterAttackPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCMonsterAttackPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCMonsterAttackPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCMonsterAttackPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCMonsterAttackPlayer.Merge(m, src)
}
func (m *SCMonsterAttackPlayer) XXX_Size() int {
	return m.Size()
}
func (m *SCMonsterAttackPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_SCMonsterAttackPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_SCMonsterAttackPlayer proto.InternalMessageInfo

func (m *SCMonsterAttackPlayer) GetHp() []*HurtPlayer {
	if m != nil {
		return m.Hp
	}
	return nil
}

func (m *SCMonsterAttackPlayer) GetLeft() []*PlayerBlood {
	if m != nil {
		return m.Left
	}
	return nil
}

//玩家死亡 恢复血量 定时发送到前端
type SCRecoveryPlayer struct {
	Left                 []*PlayerBlood `protobuf:"bytes,1,rep,name=Left" json:"Left,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SCRecoveryPlayer) Reset()         { *m = SCRecoveryPlayer{} }
func (m *SCRecoveryPlayer) String() string { return proto.CompactTextString(m) }
func (*SCRecoveryPlayer) ProtoMessage()    {}
func (*SCRecoveryPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{49}
}
func (m *SCRecoveryPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCRecoveryPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCRecoveryPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCRecoveryPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCRecoveryPlayer.Merge(m, src)
}
func (m *SCRecoveryPlayer) XXX_Size() int {
	return m.Size()
}
func (m *SCRecoveryPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_SCRecoveryPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_SCRecoveryPlayer proto.InternalMessageInfo

func (m *SCRecoveryPlayer) GetLeft() []*PlayerBlood {
	if m != nil {
		return m.Left
	}
	return nil
}

//当前闯关信息
type SCCurLevelInfo struct {
	MapID                *int32   `protobuf:"varint,1,opt,name=MapID" json:"MapID,omitempty"`
	PathID               *int32   `protobuf:"varint,2,opt,name=PathID" json:"PathID,omitempty"`
	Node                 *int32   `protobuf:"varint,3,opt,name=Node" json:"Node,omitempty"`
	Stamp                *int64   `protobuf:"varint,4,opt,name=Stamp" json:"Stamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCCurLevelInfo) Reset()         { *m = SCCurLevelInfo{} }
func (m *SCCurLevelInfo) String() string { return proto.CompactTextString(m) }
func (*SCCurLevelInfo) ProtoMessage()    {}
func (*SCCurLevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{50}
}
func (m *SCCurLevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCurLevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCurLevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCurLevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCurLevelInfo.Merge(m, src)
}
func (m *SCCurLevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *SCCurLevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCurLevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SCCurLevelInfo proto.InternalMessageInfo

func (m *SCCurLevelInfo) GetMapID() int32 {
	if m != nil && m.MapID != nil {
		return *m.MapID
	}
	return 0
}

func (m *SCCurLevelInfo) GetPathID() int32 {
	if m != nil && m.PathID != nil {
		return *m.PathID
	}
	return 0
}

func (m *SCCurLevelInfo) GetNode() int32 {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return 0
}

func (m *SCCurLevelInfo) GetStamp() int64 {
	if m != nil && m.Stamp != nil {
		return *m.Stamp
	}
	return 0
}

//玩家血量信息
type PlayerHP struct {
	PlayerID             *int64   `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	LeftHP               *int32   `protobuf:"varint,2,opt,name=LeftHP" json:"LeftHP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerHP) Reset()         { *m = PlayerHP{} }
func (m *PlayerHP) String() string { return proto.CompactTextString(m) }
func (*PlayerHP) ProtoMessage()    {}
func (*PlayerHP) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{51}
}
func (m *PlayerHP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerHP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerHP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerHP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerHP.Merge(m, src)
}
func (m *PlayerHP) XXX_Size() int {
	return m.Size()
}
func (m *PlayerHP) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerHP.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerHP proto.InternalMessageInfo

func (m *PlayerHP) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *PlayerHP) GetLeftHP() int32 {
	if m != nil && m.LeftHP != nil {
		return *m.LeftHP
	}
	return 0
}

// 攻击玩家
type CSHurtPlayer struct {
	CreateID             *int32    `protobuf:"varint,1,opt,name=CreateID" json:"CreateID,omitempty"`
	PH                   *PlayerHP `protobuf:"bytes,2,opt,name=PH" json:"PH,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CSHurtPlayer) Reset()         { *m = CSHurtPlayer{} }
func (m *CSHurtPlayer) String() string { return proto.CompactTextString(m) }
func (*CSHurtPlayer) ProtoMessage()    {}
func (*CSHurtPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{52}
}
func (m *CSHurtPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSHurtPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSHurtPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSHurtPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSHurtPlayer.Merge(m, src)
}
func (m *CSHurtPlayer) XXX_Size() int {
	return m.Size()
}
func (m *CSHurtPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_CSHurtPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_CSHurtPlayer proto.InternalMessageInfo

func (m *CSHurtPlayer) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *CSHurtPlayer) GetPH() *PlayerHP {
	if m != nil {
		return m.PH
	}
	return nil
}

//push给桌子中其他玩家 自己不需要
type SCHurtPlayer struct {
	PlayerID             *int64    `protobuf:"varint,1,opt,name=PlayerID" json:"PlayerID,omitempty"`
	CreateID             *int32    `protobuf:"varint,2,opt,name=CreateID" json:"CreateID,omitempty"`
	PH                   *PlayerHP `protobuf:"bytes,3,opt,name=PH" json:"PH,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SCHurtPlayer) Reset()         { *m = SCHurtPlayer{} }
func (m *SCHurtPlayer) String() string { return proto.CompactTextString(m) }
func (*SCHurtPlayer) ProtoMessage()    {}
func (*SCHurtPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{53}
}
func (m *SCHurtPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCHurtPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCHurtPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCHurtPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCHurtPlayer.Merge(m, src)
}
func (m *SCHurtPlayer) XXX_Size() int {
	return m.Size()
}
func (m *SCHurtPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_SCHurtPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_SCHurtPlayer proto.InternalMessageInfo

func (m *SCHurtPlayer) GetPlayerID() int64 {
	if m != nil && m.PlayerID != nil {
		return *m.PlayerID
	}
	return 0
}

func (m *SCHurtPlayer) GetCreateID() int32 {
	if m != nil && m.CreateID != nil {
		return *m.CreateID
	}
	return 0
}

func (m *SCHurtPlayer) GetPH() *PlayerHP {
	if m != nil {
		return m.PH
	}
	return nil
}

//玩家血量恢复
type CSPlayerHPChange struct {
	PH                   *PlayerHP `protobuf:"bytes,1,opt,name=PH" json:"PH,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CSPlayerHPChange) Reset()         { *m = CSPlayerHPChange{} }
func (m *CSPlayerHPChange) String() string { return proto.CompactTextString(m) }
func (*CSPlayerHPChange) ProtoMessage()    {}
func (*CSPlayerHPChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{54}
}
func (m *CSPlayerHPChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSPlayerHPChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSPlayerHPChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSPlayerHPChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSPlayerHPChange.Merge(m, src)
}
func (m *CSPlayerHPChange) XXX_Size() int {
	return m.Size()
}
func (m *CSPlayerHPChange) XXX_DiscardUnknown() {
	xxx_messageInfo_CSPlayerHPChange.DiscardUnknown(m)
}

var xxx_messageInfo_CSPlayerHPChange proto.InternalMessageInfo

func (m *CSPlayerHPChange) GetPH() *PlayerHP {
	if m != nil {
		return m.PH
	}
	return nil
}

//push给桌子中其他玩家 自己不需要
type SCPlayerHPChange struct {
	PH                   *PlayerHP `protobuf:"bytes,1,opt,name=PH" json:"PH,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SCPlayerHPChange) Reset()         { *m = SCPlayerHPChange{} }
func (m *SCPlayerHPChange) String() string { return proto.CompactTextString(m) }
func (*SCPlayerHPChange) ProtoMessage()    {}
func (*SCPlayerHPChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_fca66b22b9d6038c, []int{55}
}
func (m *SCPlayerHPChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCPlayerHPChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCPlayerHPChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCPlayerHPChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCPlayerHPChange.Merge(m, src)
}
func (m *SCPlayerHPChange) XXX_Size() int {
	return m.Size()
}
func (m *SCPlayerHPChange) XXX_DiscardUnknown() {
	xxx_messageInfo_SCPlayerHPChange.DiscardUnknown(m)
}

var xxx_messageInfo_SCPlayerHPChange proto.InternalMessageInfo

func (m *SCPlayerHPChange) GetPH() *PlayerHP {
	if m != nil {
		return m.PH
	}
	return nil
}

func init() {
	proto.RegisterEnum("biohouse.GameCommand", GameCommand_name, GameCommand_value)
	proto.RegisterEnum("biohouse.BiohouseErrCode", BiohouseErrCode_name, BiohouseErrCode_value)
	proto.RegisterEnum("biohouse.SkillID", SkillID_name, SkillID_value)
	proto.RegisterEnum("biohouse.MaterialType", MaterialType_name, MaterialType_value)
	proto.RegisterType((*CSPing)(nil), "biohouse.CSPing")
	proto.RegisterType((*SCPing)(nil), "biohouse.SCPing")
	proto.RegisterType((*WeaponInfo)(nil), "biohouse.WeaponInfo")
	proto.RegisterType((*CSLogin)(nil), "biohouse.CSLogin")
	proto.RegisterType((*SCLogin)(nil), "biohouse.SCLogin")
	proto.RegisterType((*CSLogout)(nil), "biohouse.CSLogout")
	proto.RegisterType((*SCLogout)(nil), "biohouse.SCLogout")
	proto.RegisterType((*TablePlayer)(nil), "biohouse.TablePlayer")
	proto.RegisterType((*CSEnterTable)(nil), "biohouse.CSEnterTable")
	proto.RegisterType((*SCEnterTable)(nil), "biohouse.SCEnterTable")
	proto.RegisterType((*CSLeaveTable)(nil), "biohouse.CSLeaveTable")
	proto.RegisterType((*SCLeaveTable)(nil), "biohouse.SCLeaveTable")
	proto.RegisterType((*SCMoney)(nil), "biohouse.SCMoney")
	proto.RegisterType((*CSAttack)(nil), "biohouse.CSAttack")
	proto.RegisterType((*BloodLeft)(nil), "biohouse.BloodLeft")
	proto.RegisterType((*SCAttack)(nil), "biohouse.SCAttack")
	proto.RegisterType((*SCVipLevel)(nil), "biohouse.SCVipLevel")
	proto.RegisterType((*PropsInfo)(nil), "biohouse.PropsInfo")
	proto.RegisterType((*SCPropsInfo)(nil), "biohouse.SCPropsInfo")
	proto.RegisterType((*CSUseSkill)(nil), "biohouse.CSUseSkill")
	proto.RegisterType((*SCUseSkill)(nil), "biohouse.SCUseSkill")
	proto.RegisterType((*PointInfo)(nil), "biohouse.PointInfo")
	proto.RegisterType((*MonsterInfo)(nil), "biohouse.MonsterInfo")
	proto.RegisterType((*SCNewMonster)(nil), "biohouse.SCNewMonster")
	proto.RegisterType((*MaterialInfo)(nil), "biohouse.MaterialInfo")
	proto.RegisterType((*CSMaterial)(nil), "biohouse.CSMaterial")
	proto.RegisterType((*SCMaterial)(nil), "biohouse.SCMaterial")
	proto.RegisterType((*SCChangeMaterial)(nil), "biohouse.SCChangeMaterial")
	proto.RegisterType((*CSChangeEquipWeaponID)(nil), "biohouse.CSChangeEquipWeaponID")
	proto.RegisterType((*SCChangeEquipWeaponID)(nil), "biohouse.SCChangeEquipWeaponID")
	proto.RegisterType((*CSChangeHandWeapon)(nil), "biohouse.CSChangeHandWeapon")
	proto.RegisterType((*SCChangeHandWeapon)(nil), "biohouse.SCChangeHandWeapon")
	proto.RegisterType((*CSChangeWeaponPart)(nil), "biohouse.CSChangeWeaponPart")
	proto.RegisterType((*SCChangeWeaponPart)(nil), "biohouse.SCChangeWeaponPart")
	proto.RegisterType((*CSUpgradeWeaponPart)(nil), "biohouse.CSUpgradeWeaponPart")
	proto.RegisterType((*SCUpgradeWeaponPart)(nil), "biohouse.SCUpgradeWeaponPart")
	proto.RegisterType((*CSChangeRatio)(nil), "biohouse.CSChangeRatio")
	proto.RegisterType((*SCChangeRatio)(nil), "biohouse.SCChangeRatio")
	proto.RegisterType((*CSWeaponReload)(nil), "biohouse.CSWeaponReload")
	proto.RegisterType((*SCWeaponReload)(nil), "biohouse.SCWeaponReload")
	proto.RegisterType((*CSAimMove)(nil), "biohouse.CSAimMove")
	proto.RegisterType((*SCAimMove)(nil), "biohouse.SCAimMove")
	proto.RegisterType((*CSAttackNull)(nil), "biohouse.CSAttackNull")
	proto.RegisterType((*SCAttackNull)(nil), "biohouse.SCAttackNull")
	proto.RegisterType((*SCPassLevel)(nil), "biohouse.SCPassLevel")
	proto.RegisterType((*HurtBlood)(nil), "biohouse.HurtBlood")
	proto.RegisterType((*HurtPlayer)(nil), "biohouse.HurtPlayer")
	proto.RegisterType((*PlayerBlood)(nil), "biohouse.PlayerBlood")
	proto.RegisterType((*SCMonsterAttackPlayer)(nil), "biohouse.SCMonsterAttackPlayer")
	proto.RegisterType((*SCRecoveryPlayer)(nil), "biohouse.SCRecoveryPlayer")
	proto.RegisterType((*SCCurLevelInfo)(nil), "biohouse.SCCurLevelInfo")
	proto.RegisterType((*PlayerHP)(nil), "biohouse.PlayerHP")
	proto.RegisterType((*CSHurtPlayer)(nil), "biohouse.CSHurtPlayer")
	proto.RegisterType((*SCHurtPlayer)(nil), "biohouse.SCHurtPlayer")
	proto.RegisterType((*CSPlayerHPChange)(nil), "biohouse.CSPlayerHPChange")
	proto.RegisterType((*SCPlayerHPChange)(nil), "biohouse.SCPlayerHPChange")
}

func init() { proto.RegisterFile("biohouse.proto", fileDescriptor_fca66b22b9d6038c) }

var fileDescriptor_fca66b22b9d6038c = []byte{
	// 2825 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xdd, 0x73, 0x1c, 0xc5,
	0xb5, 0x67, 0x76, 0x25, 0xef, 0xa8, 0x25, 0xcb, 0xa3, 0xd6, 0xd7, 0x7a, 0x2d, 0xc9, 0xba, 0xcd,
	0xe5, 0x62, 0x54, 0x14, 0xe6, 0x52, 0x75, 0xa9, 0x4b, 0xaa, 0x20, 0x65, 0x8d, 0x8c, 0x77, 0x2b,
	0xd2, 0x66, 0x3d, 0x6b, 0x81, 0xe1, 0x21, 0xf1, 0xa0, 0x6d, 0xaf, 0x26, 0x1e, 0x4d, 0xaf, 0x66,
	0x66, 0x8d, 0x55, 0xc9, 0x03, 0x9f, 0x81, 0x90, 0x40, 0x20, 0x24, 0x55, 0xf9, 0x13, 0xf2, 0x9e,
	0x7f, 0x22, 0x2f, 0xa9, 0x4a, 0x55, 0xfe, 0x81, 0x14, 0x49, 0x55, 0x02, 0x21, 0x40, 0x20, 0x24,
	0x40, 0x3e, 0xeb, 0x9c, 0xee, 0x9e, 0xe9, 0xd9, 0x5d, 0x49, 0xe0, 0xe4, 0x6d, 0xce, 0xe9, 0xee,
	0xdf, 0xf9, 0xe8, 0xf3, 0x35, 0x33, 0x64, 0xfa, 0xa9, 0x40, 0xec, 0x8a, 0x7e, 0xc2, 0xef, 0xeb,
	0xc5, 0x22, 0x15, 0xd4, 0xd6, 0x74, 0x6d, 0xa9, 0x2b, 0x44, 0x37, 0xe4, 0xe7, 0xfd, 0x5e, 0x70,
	0xde, 0x8f, 0x22, 0x91, 0xfa, 0x69, 0x20, 0xa2, 0x44, 0xee, 0x63, 0x36, 0x39, 0xe1, 0xb6, 0x5b,
	0x41, 0xd4, 0x65, 0xab, 0xe4, 0x44, 0xdb, 0x85, 0x27, 0xba, 0x40, 0x4e, 0xb8, 0xfd, 0xb8, 0xcd,
	0x77, 0xaa, 0xd6, 0xaa, 0x75, 0xae, 0xec, 0x29, 0x8a, 0x7d, 0x89, 0x90, 0xc7, 0xb9, 0xdf, 0x13,
	0x51, 0x23, 0xba, 0x2e, 0xe8, 0x34, 0x29, 0x35, 0x36, 0x70, 0xc7, 0xb8, 0x57, 0x6a, 0x6c, 0xd0,
	0x25, 0x32, 0x71, 0x71, 0xbf, 0x1f, 0xf4, 0x5a, 0x7e, 0x9c, 0x56, 0x4b, 0xab, 0xd6, 0xb9, 0x09,
	0x2f, 0x67, 0xb0, 0x80, 0x54, 0xdc, 0xf6, 0xa6, 0xe8, 0x06, 0x11, 0xad, 0x11, 0xbb, 0x15, 0xfa,
	0x07, 0x3c, 0x56, 0xc7, 0xcb, 0x5e, 0x46, 0xd3, 0x39, 0x32, 0x7e, 0x45, 0xdc, 0xe0, 0x91, 0x02,
	0x90, 0x04, 0xad, 0x92, 0xca, 0x63, 0x3c, 0x4e, 0x02, 0x11, 0x55, 0xcb, 0x28, 0x4f, 0x93, 0x94,
	0x92, 0xb1, 0x2d, 0xd1, 0xe1, 0xd5, 0x31, 0x64, 0xe3, 0x33, 0xfb, 0x26, 0xa9, 0xb4, 0x5d, 0x29,
	0x6a, 0x8e, 0x8c, 0x6f, 0x89, 0x88, 0x1f, 0x28, 0x39, 0x92, 0x00, 0x38, 0x54, 0xac, 0xb1, 0x51,
	0x2d, 0xad, 0x96, 0x01, 0x4e, 0x91, 0x60, 0x79, 0xdd, 0x8f, 0x3a, 0x8d, 0x0d, 0x25, 0x47, 0x51,
	0xf4, 0x1c, 0x19, 0x03, 0x9b, 0xab, 0x63, 0xab, 0xe5, 0x73, 0x93, 0x0f, 0xcc, 0xdd, 0x97, 0x39,
	0x3b, 0xf7, 0x87, 0x87, 0x3b, 0x18, 0x21, 0x36, 0xda, 0x29, 0xfa, 0x29, 0x5b, 0x23, 0x36, 0x2a,
	0x22, 0xfa, 0x29, 0x5d, 0x21, 0x44, 0x3e, 0x5d, 0x39, 0xe8, 0x71, 0xe5, 0x35, 0x83, 0xc3, 0x7e,
	0x5e, 0x22, 0x93, 0x57, 0xfc, 0xa7, 0x42, 0x2e, 0x5d, 0x71, 0x9c, 0x93, 0xa4, 0x55, 0xa5, 0x01,
	0xab, 0xdc, 0x5d, 0x3f, 0x88, 0x1b, 0x1d, 0xed, 0x24, 0x45, 0x02, 0xd6, 0x63, 0x41, 0x6f, 0x93,
	0xdf, 0xe4, 0xa1, 0x72, 0x54, 0x46, 0x83, 0x5e, 0xeb, 0xfe, 0xce, 0x8d, 0x6e, 0x2c, 0xfa, 0x51,
	0xa7, 0x3a, 0x2e, 0xf5, 0xca, 0x39, 0xa8, 0x87, 0x88, 0xd3, 0xd8, 0x0f, 0xd2, 0xea, 0x09, 0xbc,
	0x93, 0x8c, 0x06, 0xe7, 0x37, 0x83, 0x9d, 0x1b, 0xd5, 0x0a, 0xf2, 0xf1, 0xd9, 0xf0, 0xa0, 0x5d,
	0xf0, 0xa0, 0xe1, 0xf3, 0x89, 0xa2, 0xcf, 0xb5, 0x6f, 0xc9, 0x71, 0xbe, 0x05, 0xbb, 0x3d, 0x08,
	0xde, 0xea, 0x24, 0x42, 0x4b, 0x02, 0xb8, 0xeb, 0xa1, 0x10, 0x9d, 0xea, 0x94, 0xe4, 0x22, 0xc1,
	0x18, 0x99, 0x72, 0xdb, 0x17, 0xa3, 0x94, 0xc7, 0xe8, 0xd5, 0x2c, 0x50, 0x2c, 0x23, 0x50, 0xda,
	0x64, 0xaa, 0xed, 0x1a, 0x7b, 0xee, 0x51, 0x9a, 0x58, 0xa8, 0xc9, 0x7c, 0xae, 0x89, 0x71, 0x31,
	0x4a, 0x95, 0x2a, 0xa9, 0x20, 0x13, 0x43, 0x08, 0x9d, 0xad, 0x48, 0x36, 0x0d, 0x82, 0x37, 0xb9,
	0x7f, 0x93, 0x23, 0x87, 0xad, 0x81, 0x90, 0x9c, 0x3e, 0xea, 0x62, 0xd9, 0x0d, 0x88, 0x5c, 0x79,
	0x9b, 0x5f, 0xfc, 0xfe, 0x29, 0x19, 0xc3, 0xd8, 0x92, 0x97, 0x8f, 0xcf, 0x80, 0xe2, 0xc6, 0xdc,
	0x4f, 0x41, 0x4f, 0x75, 0xf3, 0x9a, 0x66, 0x8f, 0x40, 0xa4, 0x5e, 0x48, 0x53, 0x7f, 0xe7, 0x46,
	0x61, 0x9f, 0x55, 0xdc, 0x07, 0x37, 0x0a, 0x19, 0x9c, 0x59, 0xaa, 0x28, 0x76, 0x91, 0x4c, 0xa0,
	0xab, 0x37, 0xf9, 0xf5, 0x14, 0xd5, 0xf5, 0x63, 0x33, 0xb8, 0x33, 0x1a, 0x0a, 0x03, 0xec, 0x91,
	0x97, 0x24, 0x31, 0x72, 0x06, 0xfb, 0xa9, 0x05, 0x59, 0x92, 0xeb, 0x71, 0xa8, 0xd5, 0xa6, 0x8e,
	0xa5, 0x01, 0x1d, 0x33, 0x8f, 0x94, 0x4d, 0x8f, 0x14, 0x04, 0x8f, 0x0d, 0x08, 0xa6, 0x77, 0x93,
	0x31, 0x20, 0x30, 0xe6, 0x27, 0x1f, 0x98, 0xcd, 0x6f, 0x3b, 0xb3, 0xca, 0xc3, 0x0d, 0xe0, 0x58,
	0x37, 0x0c, 0x7a, 0x18, 0xfe, 0xe3, 0x1e, 0x3e, 0xb3, 0x0d, 0x42, 0xda, 0x6e, 0x96, 0x44, 0xc7,
	0xa8, 0x9d, 0x25, 0x5f, 0xa9, 0x98, 0x7c, 0xec, 0xeb, 0x64, 0xa2, 0x15, 0x8b, 0x5e, 0xa2, 0x43,
	0x4a, 0x12, 0xfa, 0x0a, 0x34, 0x89, 0xf0, 0xf0, 0xd8, 0xec, 0xef, 0xa9, 0x2b, 0xcf, 0x68, 0xb0,
	0xd1, 0xdd, 0xf5, 0xa3, 0x2e, 0x87, 0x45, 0x69, 0x7d, 0xce, 0x60, 0x1e, 0x99, 0x6c, 0xbb, 0xb9,
	0x88, 0xa3, 0xf4, 0xbc, 0x5b, 0x05, 0x7f, 0x09, 0x83, 0xdf, 0x70, 0x47, 0x76, 0x5c, 0x55, 0xb8,
	0xff, 0x27, 0xc4, 0x6d, 0x6f, 0x27, 0xbc, 0x7d, 0x23, 0x08, 0x43, 0xd0, 0x1a, 0x1f, 0x72, 0xad,
	0x15, 0x49, 0x1d, 0x52, 0xde, 0x4e, 0x38, 0x2a, 0x6c, 0x7b, 0xf0, 0xc8, 0xae, 0x80, 0xd3, 0x6e,
	0xe7, 0x64, 0x41, 0xf1, 0xf2, 0x40, 0xd2, 0xfc, 0x1f, 0x99, 0x68, 0x89, 0x20, 0x4a, 0xd1, 0xc2,
	0x29, 0x62, 0x5d, 0x45, 0xb8, 0x92, 0x67, 0x5d, 0x05, 0xea, 0x09, 0x84, 0x29, 0x79, 0xd6, 0x13,
	0x40, 0x3d, 0x89, 0xa7, 0x4b, 0x9e, 0xf5, 0x24, 0x7b, 0xa9, 0x44, 0x26, 0xb7, 0x44, 0x94, 0xa4,
	0x3c, 0xd6, 0xbe, 0xd9, 0x0c, 0x22, 0x6e, 0x46, 0xb0, 0xa6, 0x8f, 0x0c, 0xbd, 0x25, 0x32, 0xa1,
	0x61, 0x74, 0xd7, 0xc8, 0x19, 0xf4, 0x1e, 0x32, 0x8e, 0xca, 0xa9, 0xce, 0x61, 0xba, 0x55, 0xeb,
	0xec, 0xc9, 0x1d, 0x00, 0xb4, 0xce, 0xbb, 0x41, 0x74, 0x25, 0xd8, 0xe3, 0x18, 0x6b, 0x65, 0x2f,
	0x67, 0x60, 0xfd, 0x8c, 0x3a, 0xb8, 0x56, 0xc1, 0x35, 0x4d, 0x1a, 0x71, 0x5c, 0x3e, 0x3a, 0x8e,
	0x17, 0xc8, 0x89, 0x0b, 0x0d, 0xb4, 0x4f, 0x95, 0x66, 0x49, 0xb1, 0x87, 0xa0, 0x42, 0x35, 0xf9,
	0xd3, 0x4a, 0xeb, 0xc3, 0xcb, 0xa0, 0xe1, 0x2e, 0x15, 0x0b, 0xf7, 0x93, 0xa9, 0x2d, 0x3f, 0xe5,
	0x71, 0xe0, 0x87, 0x23, 0x67, 0x02, 0x87, 0x94, 0x75, 0xd0, 0x8e, 0x7b, 0xf0, 0xc8, 0xa6, 0x20,
	0x7a, 0xf4, 0x19, 0xf6, 0x08, 0x44, 0x84, 0xa6, 0xe8, 0xfd, 0xa4, 0xb2, 0xe5, 0xa7, 0x86, 0xec,
	0x05, 0x43, 0xb6, 0x21, 0xc6, 0xd3, 0xdb, 0xd8, 0x4f, 0x2c, 0xe2, 0xb4, 0x5d, 0x19, 0xef, 0xb7,
	0x0f, 0x43, 0xd7, 0x54, 0xe9, 0x04, 0x3d, 0xa7, 0x47, 0x6d, 0x87, 0xd5, 0xbc, 0xa4, 0x1e, 0x16,
	0x8a, 0x47, 0x96, 0xdb, 0xff, 0x25, 0xf3, 0x6e, 0x5b, 0x6a, 0x8a, 0x9d, 0x4f, 0x75, 0xb7, 0x42,
	0x67, 0xb4, 0x0a, 0x9d, 0x91, 0x2d, 0x92, 0x79, 0x6d, 0x5c, 0xe1, 0x08, 0xbb, 0x97, 0x50, 0x8d,
	0x05, 0xed, 0x55, 0xf2, 0x8d, 0xd6, 0x6b, 0x99, 0xad, 0x97, 0x7d, 0x8d, 0x50, 0x0d, 0x63, 0xec,
	0x3e, 0xaa, 0x16, 0xe4, 0x48, 0xa5, 0x42, 0x13, 0xcf, 0x1a, 0x70, 0xd9, 0x68, 0xc0, 0xec, 0xa9,
	0x5c, 0x1b, 0x89, 0x0d, 0x95, 0x1f, 0xf0, 0xb5, 0xbe, 0x3a, 0x9f, 0x32, 0x93, 0x0f, 0x69, 0x29,
	0xe0, 0x8a, 0xcb, 0x7d, 0x3f, 0x0c, 0xd2, 0x03, 0x3d, 0xc2, 0x28, 0x92, 0x3d, 0x92, 0xdb, 0x60,
	0xc8, 0x38, 0x97, 0x45, 0xaa, 0x75, 0xcc, 0x58, 0xd6, 0x20, 0xb3, 0x6e, 0x7b, 0xbb, 0xd7, 0x8d,
	0xfd, 0xce, 0xbf, 0xa9, 0x24, 0xfb, 0x32, 0x99, 0x6d, 0xbb, 0xc3, 0x50, 0x9f, 0x5f, 0x97, 0xbb,
	0xc8, 0x49, 0xed, 0xaf, 0x6c, 0x82, 0x91, 0x6e, 0xb5, 0x4c, 0xb7, 0x5e, 0x20, 0x27, 0xb5, 0xc9,
	0x72, 0xdb, 0x31, 0x23, 0x81, 0x84, 0x28, 0x99, 0x10, 0x0e, 0x99, 0x76, 0xdb, 0x52, 0xbe, 0xc7,
	0x43, 0xe1, 0x77, 0xd8, 0xbd, 0x64, 0xba, 0xed, 0x9a, 0x9c, 0x23, 0xe7, 0x91, 0x07, 0xc9, 0x84,
	0xdb, 0xbe, 0x10, 0xec, 0x6d, 0x89, 0x9b, 0x3c, 0x2f, 0x65, 0xd6, 0x60, 0xc3, 0x1c, 0x2c, 0x65,
	0xcc, 0x23, 0x13, 0x6d, 0x57, 0x9f, 0x3b, 0x4a, 0xed, 0x0c, 0xb3, 0x74, 0x2c, 0xe6, 0x43, 0x30,
	0x57, 0xc9, 0x31, 0xa1, 0xd9, 0x0f, 0xc3, 0x2f, 0xa2, 0xce, 0x36, 0x14, 0x38, 0xe3, 0xe8, 0x7f,
	0x48, 0xa3, 0xe7, 0x2d, 0xec, 0xae, 0x7e, 0x92, 0xc8, 0x29, 0x00, 0x1a, 0x5a, 0x7f, 0x67, 0x87,
	0x27, 0x09, 0xa2, 0xda, 0x9e, 0x26, 0x61, 0xa5, 0xc9, 0x9f, 0x86, 0x9d, 0xaa, 0xa9, 0x69, 0x12,
	0x07, 0x17, 0xbf, 0x97, 0x75, 0x0e, 0x49, 0xe0, 0x60, 0x6d, 0xbc, 0xd5, 0xc0, 0xb3, 0x0c, 0xc7,
	0x74, 0xb7, 0xb1, 0xa1, 0x86, 0x74, 0x45, 0xb1, 0x87, 0xc9, 0x44, 0xbd, 0x1f, 0xab, 0x99, 0xe6,
	0x98, 0x10, 0x31, 0x47, 0x30, 0x35, 0x27, 0x5f, 0x26, 0x04, 0x8e, 0xe7, 0x6f, 0x1d, 0x87, 0xce,
	0x81, 0x77, 0x93, 0x31, 0xd8, 0x39, 0x3c, 0x20, 0x64, 0xe2, 0x3d, 0xdc, 0xc0, 0x9e, 0x20, 0x93,
	0x12, 0xee, 0x36, 0x75, 0x02, 0x77, 0xd5, 0xfd, 0x64, 0x23, 0xe0, 0xf2, 0x4d, 0xc6, 0xf6, 0x34,
	0xc9, 0x76, 0xa1, 0x22, 0xaa, 0x36, 0x24, 0x2f, 0x54, 0x29, 0xfe, 0xdf, 0xa4, 0x54, 0xef, 0xa9,
	0x72, 0x3f, 0x57, 0x54, 0x4d, 0xcd, 0xed, 0xa5, 0x7a, 0x0f, 0x3a, 0x1b, 0xb6, 0xca, 0xd2, 0x60,
	0x67, 0x33, 0xf4, 0x95, 0xcd, 0x92, 0x3d, 0x0c, 0x8d, 0xc5, 0xe3, 0x3b, 0xe2, 0x26, 0x8f, 0x0f,
	0x94, 0x10, 0x7d, 0xdc, 0x3a, 0xfe, 0xf8, 0x2e, 0xe4, 0x99, 0xdb, 0x8f, 0x31, 0x32, 0xf4, 0xcb,
	0x8b, 0xbc, 0x69, 0xcb, 0xbc, 0xe9, 0xfc, 0x56, 0x4b, 0xe6, 0xad, 0x66, 0x11, 0x50, 0x36, 0x22,
	0x60, 0x8e, 0x8c, 0xb7, 0x53, 0x7f, 0xaf, 0x87, 0x61, 0x51, 0xf6, 0x24, 0x01, 0x63, 0xbc, 0x14,
	0x5f, 0x6f, 0x1d, 0x57, 0xd3, 0x41, 0xb3, 0x7a, 0x4b, 0x4b, 0x92, 0x14, 0x6b, 0x42, 0x5e, 0x7d,
	0xce, 0x10, 0x60, 0xa4, 0xd4, 0xaa, 0xab, 0xcc, 0xa0, 0x83, 0xe6, 0xd7, 0x5b, 0x5e, 0xa9, 0x55,
	0x67, 0xdf, 0x80, 0x64, 0x2b, 0xe2, 0xdd, 0xd6, 0x48, 0x2f, 0x65, 0x95, 0x8f, 0x94, 0xf5, 0x20,
	0x71, 0xdc, 0xb6, 0xe6, 0xc8, 0x52, 0xa9, 0xce, 0x59, 0xc7, 0x9d, 0x6b, 0xbb, 0x5f, 0xfc, 0xdc,
	0xda, 0x47, 0x27, 0xc8, 0xe4, 0x25, 0x7f, 0x8f, 0xbb, 0x62, 0x6f, 0xcf, 0x8f, 0x3a, 0x74, 0x92,
	0x54, 0x9a, 0x22, 0xdd, 0x0d, 0xa2, 0xae, 0x73, 0x07, 0x9d, 0x22, 0x15, 0x8f, 0xef, 0xb7, 0x80,
	0xf8, 0x5d, 0x85, 0x9e, 0x24, 0xb6, 0xc7, 0xf7, 0xf1, 0x2b, 0x84, 0xf3, 0x76, 0x85, 0x4e, 0x93,
	0x09, 0x49, 0x8a, 0x7e, 0xea, 0xbc, 0x53, 0xa1, 0xa7, 0x08, 0x69, 0xf5, 0x93, 0x5d, 0xc5, 0xf8,
	0x7d, 0x85, 0xce, 0x92, 0x69, 0x60, 0xe4, 0x63, 0x98, 0xf3, 0x2e, 0x9e, 0x02, 0x26, 0xbe, 0xcd,
	0x38, 0xef, 0x69, 0x14, 0x19, 0xf8, 0xce, 0xfb, 0x19, 0x8a, 0x62, 0x7c, 0xa0, 0xa5, 0x7a, 0xdc,
	0xef, 0x1c, 0x38, 0x7f, 0xac, 0x50, 0x87, 0x4c, 0x7a, 0x7c, 0x5f, 0x0f, 0x31, 0xce, 0x87, 0x15,
	0x7a, 0x86, 0x2c, 0x78, 0x7c, 0x7f, 0xc4, 0x4c, 0xe1, 0x7c, 0x54, 0xa1, 0x55, 0x32, 0x9b, 0x2d,
	0xe6, 0x93, 0x82, 0xf3, 0xa7, 0x0a, 0x3d, 0x4d, 0xe6, 0x40, 0xd0, 0xd0, 0xd2, 0xc7, 0x15, 0x3a,
	0x47, 0x4e, 0xc1, 0x92, 0x01, 0xe6, 0xfc, 0x19, 0xb9, 0x1e, 0xdf, 0x37, 0x1b, 0x8d, 0xf3, 0x97,
	0x0a, 0x9d, 0x27, 0x0e, 0xec, 0x2d, 0xb0, 0x3f, 0x41, 0x33, 0xc0, 0x2c, 0xd9, 0x2f, 0x9c, 0x4f,
	0x51, 0x6f, 0xb4, 0x4b, 0x71, 0x3e, 0xab, 0x50, 0x4a, 0x4e, 0x66, 0x96, 0x43, 0x0d, 0x77, 0xfe,
	0x9a, 0xb9, 0xcc, 0x60, 0xfe, 0xad, 0x68, 0x43, 0xde, 0x9d, 0x9d, 0xbf, 0xa3, 0x0d, 0x1e, 0xdf,
	0x1f, 0x6a, 0xdc, 0xce, 0x3f, 0x10, 0x29, 0x3b, 0x84, 0x9d, 0xd3, 0xf9, 0x67, 0x66, 0x98, 0xc9,
	0x7d, 0xc6, 0x56, 0x8a, 0xe4, 0x1f, 0x0d, 0x9c, 0x67, 0x6d, 0xad, 0x88, 0xc1, 0x7c, 0x4e, 0x6f,
	0xcc, 0x5f, 0xfc, 0x9d, 0xe7, 0xb3, 0x8d, 0x06, 0xf3, 0x05, 0x9b, 0x2e, 0x12, 0x9a, 0xcb, 0xc9,
	0xee, 0xea, 0x45, 0x5b, 0xdd, 0x9e, 0x7e, 0x5f, 0x72, 0xbe, 0x6d, 0xd3, 0x19, 0x32, 0x05, 0x5b,
	0x33, 0xd6, 0x4b, 0x28, 0x06, 0x58, 0x59, 0x17, 0x72, 0x5e, 0xb6, 0xe9, 0x12, 0x59, 0x54, 0x61,
	0x33, 0x58, 0x27, 0x9d, 0xef, 0x64, 0xf2, 0x8a, 0xb5, 0xcd, 0x79, 0x25, 0x43, 0xd7, 0x6f, 0xa7,
	0xce, 0x77, 0x73, 0x74, 0xfd, 0x0a, 0xe8, 0x7c, 0xcf, 0xd6, 0x97, 0x68, 0x16, 0x37, 0xe7, 0x55,
	0x6d, 0x6f, 0x9e, 0xf8, 0xce, 0x6b, 0x99, 0xbd, 0x06, 0xf3, 0xfb, 0x36, 0x5d, 0x20, 0x33, 0x90,
	0x27, 0x85, 0xec, 0x73, 0x5e, 0xcf, 0xf4, 0x1a, 0x58, 0x78, 0xc3, 0x5e, 0xfb, 0xad, 0x4d, 0x4e,
	0xad, 0xab, 0x7c, 0xbc, 0x18, 0xc7, 0x2e, 0xd4, 0xc2, 0xc9, 0xac, 0xd7, 0x3a, 0x77, 0xa0, 0x18,
	0x3c, 0xd5, 0x14, 0xe9, 0xc5, 0x5b, 0x41, 0x92, 0x42, 0x02, 0x9e, 0x22, 0xa4, 0x29, 0xd2, 0x46,
	0x24, 0xfd, 0xfc, 0x76, 0x05, 0xf0, 0xf1, 0x86, 0x3c, 0x21, 0xf6, 0x1a, 0x89, 0x1b, 0x8a, 0x04,
	0x52, 0xf5, 0x1d, 0x5c, 0x90, 0x55, 0x47, 0x82, 0x3c, 0xea, 0x07, 0x21, 0xef, 0x40, 0x4e, 0x82,
	0x46, 0xc8, 0xba, 0x10, 0xc6, 0x90, 0x52, 0x32, 0x9b, 0xdf, 0xad, 0x80, 0xa7, 0x1a, 0xd1, 0x4d,
	0x3f, 0x0c, 0x3a, 0xf8, 0x7d, 0xd2, 0xf9, 0x03, 0x46, 0xcb, 0xa6, 0xf0, 0x3b, 0xe8, 0x29, 0x85,
	0xf0, 0x1e, 0x22, 0x00, 0x77, 0x3b, 0x91, 0x6f, 0x4d, 0x6a, 0xe1, 0xfd, 0x6c, 0x01, 0x8a, 0xc9,
	0x86, 0x9f, 0xfa, 0x6a, 0xe1, 0x03, 0x8c, 0x5f, 0xd4, 0x12, 0x56, 0x9a, 0x22, 0x0d, 0xae, 0x1f,
	0xd4, 0xfd, 0x30, 0x84, 0x64, 0x9e, 0x27, 0x4e, 0x1e, 0x61, 0xea, 0xc0, 0x87, 0x12, 0x29, 0xd8,
	0x0b, 0x52, 0x8f, 0xef, 0xf7, 0x83, 0x58, 0x2f, 0x7c, 0x84, 0x0e, 0xc0, 0xfd, 0xb8, 0x0a, 0x49,
	0xbc, 0x40, 0x66, 0x50, 0xdd, 0xc7, 0x78, 0x1c, 0x5c, 0x3f, 0x50, 0x1b, 0x3f, 0xc6, 0x8d, 0xc8,
	0xbf, 0x18, 0xc7, 0x22, 0x86, 0xe4, 0x85, 0x1b, 0xf6, 0x63, 0x7f, 0x8f, 0xc3, 0xcb, 0x5e, 0xf2,
	0x78, 0x2c, 0xa2, 0x2e, 0x64, 0xef, 0x1c, 0x39, 0xa5, 0x42, 0x2a, 0xf3, 0xf3, 0x27, 0x98, 0x3b,
	0x32, 0x99, 0x32, 0xe6, 0xa7, 0x88, 0xa0, 0xb6, 0xd6, 0xfd, 0xe4, 0x2b, 0x41, 0x08, 0x92, 0x3e,
	0xc3, 0xbd, 0x58, 0xcb, 0x60, 0x6b, 0x24, 0xfa, 0xdd, 0x5d, 0x9d, 0xc6, 0x7e, 0x9c, 0x42, 0x8b,
	0xe7, 0x49, 0x1a, 0x8b, 0x03, 0x48, 0xe3, 0x79, 0xe2, 0x34, 0x05, 0xf0, 0x86, 0x72, 0x38, 0x67,
	0xa8, 0x54, 0xde, 0xf2, 0x6f, 0x41, 0x0e, 0xaf, 0x92, 0x33, 0xf9, 0x52, 0x53, 0xa4, 0x8f, 0x06,
	0x51, 0x47, 0xed, 0x70, 0xaf, 0x77, 0x21, 0xa1, 0x97, 0x49, 0x35, 0x3b, 0x22, 0xb3, 0x2c, 0xd7,
	0xe3, 0x19, 0x9b, 0xae, 0x90, 0xd3, 0xc3, 0xcb, 0x80, 0x02, 0xc7, 0x9f, 0xb5, 0xa1, 0xb6, 0xd6,
	0xfd, 0x44, 0xd6, 0xd6, 0xe7, 0x30, 0x5c, 0xb7, 0xfa, 0x49, 0x8a, 0x75, 0xef, 0xab, 0x91, 0x2a,
	0x28, 0x90, 0xe4, 0xab, 0xe4, 0x0c, 0xa8, 0xa0, 0xde, 0x5c, 0x9a, 0x22, 0xbd, 0x84, 0xc1, 0x15,
	0xab, 0x1d, 0x2f, 0x60, 0xaa, 0x40, 0x0d, 0x0d, 0x9b, 0x42, 0xf1, 0x5e, 0xb4, 0xe9, 0x59, 0x52,
	0x7b, 0x92, 0xc7, 0x42, 0x9d, 0xda, 0x4e, 0xf8, 0x06, 0xbf, 0xee, 0xf7, 0xc3, 0x54, 0x16, 0x1e,
	0x99, 0xfb, 0xf8, 0xdc, 0x08, 0x43, 0xde, 0xf5, 0x31, 0xf7, 0x97, 0xc8, 0x22, 0xb2, 0x0a, 0x02,
	0xe4, 0x81, 0x97, 0x31, 0x4f, 0x25, 0x07, 0xd2, 0xaf, 0x91, 0x00, 0x3a, 0xa4, 0x3f, 0x0a, 0x4f,
	0x8c, 0x5a, 0xf5, 0x8a, 0x8d, 0xa5, 0xce, 0x8f, 0xd3, 0xc4, 0xb8, 0x03, 0x99, 0xfc, 0x4d, 0x81,
	0x85, 0xc6, 0xf5, 0xa3, 0xed, 0x84, 0x43, 0xf2, 0x2f, 0x90, 0x19, 0x5d, 0x7d, 0x1a, 0x1b, 0x8d,
	0x44, 0x86, 0xcc, 0xab, 0x58, 0xab, 0xb6, 0x44, 0x87, 0x6b, 0xce, 0x6b, 0xb2, 0x74, 0xc8, 0x54,
	0x96, 0xb3, 0x1b, 0xa4, 0xfe, 0x32, 0xa9, 0xe6, 0x82, 0x07, 0x22, 0xe1, 0xf5, 0x81, 0x65, 0xa9,
	0x3b, 0x96, 0x98, 0xa6, 0x48, 0x9d, 0x37, 0xd0, 0xa0, 0xcb, 0x2d, 0xf0, 0xff, 0x25, 0x11, 0x76,
	0x54, 0xf8, 0xfe, 0x00, 0x55, 0xba, 0xdc, 0xca, 0x32, 0x5b, 0xf1, 0xdf, 0xc4, 0xe2, 0xa3, 0xfe,
	0x12, 0xe8, 0x18, 0xfe, 0x21, 0xba, 0xec, 0x72, 0x6b, 0xdd, 0x4f, 0xb8, 0x4e, 0xc9, 0x4b, 0x3c,
	0x55, 0x47, 0x7e, 0x64, 0xaf, 0xdd, 0x99, 0x7d, 0x92, 0x82, 0x02, 0xb3, 0x1e, 0x74, 0x21, 0x74,
	0x1d, 0x0b, 0x08, 0x78, 0x82, 0x48, 0x2b, 0xad, 0xdd, 0x95, 0x7f, 0xf3, 0xc0, 0x0f, 0x02, 0x93,
	0xa4, 0xa2, 0xe2, 0xc6, 0xb1, 0xa8, 0x4d, 0xc6, 0x36, 0x62, 0xd1, 0x73, 0x4a, 0x0f, 0xbc, 0x39,
	0x4d, 0x6c, 0x5d, 0xb5, 0x68, 0x3d, 0x9b, 0x0d, 0xa8, 0x93, 0xcf, 0x16, 0xf2, 0xc7, 0x4b, 0xcd,
	0xe0, 0xc8, 0x1f, 0x30, 0xec, 0xf4, 0x73, 0xbf, 0xfc, 0xcd, 0x9b, 0xa5, 0x59, 0x36, 0x73, 0x5e,
	0x23, 0x9c, 0xd7, 0xc7, 0x37, 0xf3, 0xb9, 0x82, 0xce, 0x98, 0x50, 0xc8, 0xaa, 0xcd, 0x98, 0x58,
	0xc8, 0x62, 0x35, 0x04, 0x9b, 0x63, 0xb4, 0x00, 0x26, 0x11, 0x5a, 0xc6, 0x58, 0x42, 0xe9, 0x00,
	0x9c, 0xe8, 0xa7, 0x35, 0x3a, 0x80, 0x27, 0xfa, 0x29, 0x3b, 0x83, 0x80, 0xf3, 0x6c, 0x76, 0x10,
	0x10, 0x40, 0x5a, 0xc6, 0x88, 0x52, 0x44, 0x94, 0xbc, 0x22, 0xa2, 0xe4, 0x1d, 0x82, 0xa8, 0x40,
	0xae, 0x16, 0x86, 0x18, 0x3a, 0x67, 0x62, 0x6a, 0x6e, 0x6d, 0xce, 0x44, 0xcd, 0x3e, 0x2f, 0x2d,
	0x23, 0xee, 0x22, 0x9b, 0x2f, 0xe0, 0x66, 0x50, 0x2f, 0x58, 0x87, 0x4d, 0x43, 0xf4, 0xac, 0x29,
	0x65, 0xc4, 0x86, 0xda, 0x59, 0x53, 0xe0, 0xa8, 0x6f, 0x34, 0xe7, 0x50, 0x36, 0x63, 0xab, 0x05,
	0xd9, 0xa3, 0x64, 0xdd, 0x1a, 0x39, 0x76, 0xd1, 0xa5, 0x61, 0x15, 0xf2, 0xd5, 0xda, 0xd2, 0xb0,
	0xfc, 0x7c, 0x95, 0xdd, 0x85, 0xc2, 0xcf, 0xb2, 0xe5, 0x11, 0xc2, 0x0d, 0x11, 0xb7, 0x46, 0x0e,
	0x4b, 0xa3, 0x24, 0xe7, 0xab, 0xa3, 0x24, 0xe7, 0xab, 0x47, 0x4a, 0x36, 0x44, 0x7c, 0x6b, 0xf4,
	0x30, 0x46, 0x97, 0x4d, 0xd1, 0x43, 0xcb, 0xb5, 0x65, 0x53, 0xf6, 0xd0, 0x32, 0xfb, 0x1f, 0x14,
	0xbe, 0xca, 0x56, 0x0a, 0xc2, 0x87, 0xa5, 0xec, 0x0e, 0x4d, 0xa7, 0xb4, 0x6a, 0x0a, 0x36, 0x57,
	0x6a, 0x55, 0x53, 0x66, 0xe1, 0x63, 0xca, 0x7f, 0xa1, 0xb8, 0x33, 0xec, 0x74, 0x41, 0x5c, 0x01,
	0xf6, 0x8a, 0x39, 0xda, 0xd2, 0xd9, 0x42, 0x3e, 0x48, 0x66, 0x6d, 0xb6, 0x90, 0x10, 0x92, 0xc9,
	0x96, 0x10, 0x7a, 0x81, 0xcd, 0x15, 0x33, 0x42, 0xe1, 0x5c, 0x1b, 0x98, 0x86, 0xe9, 0xc2, 0x70,
	0xa2, 0x01, 0xbf, 0xb6, 0x30, 0x9c, 0x6c, 0xc0, 0x67, 0x67, 0x11, 0xfe, 0x34, 0x5b, 0x1c, 0x91,
	0x70, 0x08, 0xd8, 0x19, 0x9c, 0x88, 0xe9, 0xe2, 0x70, 0x50, 0xe0, 0x42, 0x6d, 0x71, 0x38, 0x1e,
	0xe4, 0xd7, 0xa7, 0x55, 0x14, 0x52, 0x63, 0xd5, 0x11, 0xa1, 0x20, 0x31, 0xaf, 0x0d, 0x0c, 0xd3,
	0x45, 0x3b, 0x72, 0x7e, 0xd1, 0x8e, 0x9c, 0x7f, 0x88, 0x1d, 0x06, 0xe0, 0xb5, 0x81, 0x29, 0xbc,
	0x28, 0x21, 0xe7, 0x17, 0x25, 0x18, 0xbf, 0xef, 0x46, 0x4b, 0x30, 0x00, 0xaf, 0x16, 0xa6, 0xf4,
	0x62, 0x79, 0xd2, 0xdc, 0x62, 0x79, 0xd2, 0xdc, 0x43, 0xca, 0x53, 0x06, 0x75, 0x6d, 0x60, 0xa2,
	0x2e, 0xea, 0x9e, 0xf3, 0x8b, 0xba, 0xe7, 0xfc, 0x43, 0x74, 0x37, 0x00, 0x7b, 0x23, 0x46, 0x71,
	0x5a, 0x2b, 0x34, 0xa8, 0xc2, 0x5a, 0xad, 0x56, 0x68, 0x55, 0x85, 0x35, 0x76, 0x27, 0x4a, 0x5b,
	0x66, 0x67, 0x8a, 0x4d, 0xab, 0xb0, 0x69, 0xdd, 0xf9, 0xd9, 0x5b, 0x2b, 0xd6, 0x2f, 0xde, 0x5a,
	0xb1, 0x7e, 0xf5, 0xd6, 0x8a, 0xf5, 0xe3, 0x5f, 0xaf, 0xdc, 0xf1, 0xaf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x13, 0xd9, 0xac, 0x70, 0xb9, 0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BiohouseClient is the client API for Biohouse service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BiohouseClient interface {
	ReqPing(ctx context.Context, in *CSPing, opts ...grpc.CallOption) (*SCPing, error)
	ReqLogin(ctx context.Context, in *CSLogin, opts ...grpc.CallOption) (*SCLogin, error)
	ReqLogout(ctx context.Context, in *CSLogout, opts ...grpc.CallOption) (*SCLogout, error)
	ReqAttack(ctx context.Context, in *CSAttack, opts ...grpc.CallOption) (*SCAttack, error)
	ReqMaterial(ctx context.Context, in *CSMaterial, opts ...grpc.CallOption) (*SCMaterial, error)
	ReqChangeEquipWeaponID(ctx context.Context, in *CSChangeEquipWeaponID, opts ...grpc.CallOption) (*SCChangeEquipWeaponID, error)
	ReqChangeHandWeapon(ctx context.Context, in *CSChangeHandWeapon, opts ...grpc.CallOption) (*SCChangeHandWeapon, error)
	ReqChangeWeaponPart(ctx context.Context, in *CSChangeWeaponPart, opts ...grpc.CallOption) (*SCChangeWeaponPart, error)
	ReqUpgradeWeaponPart(ctx context.Context, in *CSUpgradeWeaponPart, opts ...grpc.CallOption) (*SCUpgradeWeaponPart, error)
	ReqWeaponReload(ctx context.Context, in *CSWeaponReload, opts ...grpc.CallOption) (*SCWeaponReload, error)
	ReqAimMove(ctx context.Context, in *CSAimMove, opts ...grpc.CallOption) (*SCAimMove, error)
	ReqAttackNull(ctx context.Context, in *CSAttackNull, opts ...grpc.CallOption) (*SCAttackNull, error)
	ReqChangeRatio(ctx context.Context, in *CSChangeRatio, opts ...grpc.CallOption) (*SCChangeRatio, error)
	ReqEnterTable(ctx context.Context, in *CSEnterTable, opts ...grpc.CallOption) (*SCEnterTable, error)
	ReqLeaveTable(ctx context.Context, in *CSLeaveTable, opts ...grpc.CallOption) (*SCLeaveTable, error)
	ReqUseSkill(ctx context.Context, in *CSUseSkill, opts ...grpc.CallOption) (*SCUseSkill, error)
	ReqHurtPlayer(ctx context.Context, in *CSHurtPlayer, opts ...grpc.CallOption) (*SCHurtPlayer, error)
	ReqPlayerHPChange(ctx context.Context, in *CSPlayerHPChange, opts ...grpc.CallOption) (*SCPlayerHPChange, error)
}

type biohouseClient struct {
	cc *grpc.ClientConn
}

func NewBiohouseClient(cc *grpc.ClientConn) BiohouseClient {
	return &biohouseClient{cc}
}

func (c *biohouseClient) ReqPing(ctx context.Context, in *CSPing, opts ...grpc.CallOption) (*SCPing, error) {
	out := new(SCPing)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqPing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqLogin(ctx context.Context, in *CSLogin, opts ...grpc.CallOption) (*SCLogin, error) {
	out := new(SCLogin)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqLogout(ctx context.Context, in *CSLogout, opts ...grpc.CallOption) (*SCLogout, error) {
	out := new(SCLogout)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqLogout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqAttack(ctx context.Context, in *CSAttack, opts ...grpc.CallOption) (*SCAttack, error) {
	out := new(SCAttack)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqAttack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqMaterial(ctx context.Context, in *CSMaterial, opts ...grpc.CallOption) (*SCMaterial, error) {
	out := new(SCMaterial)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqChangeEquipWeaponID(ctx context.Context, in *CSChangeEquipWeaponID, opts ...grpc.CallOption) (*SCChangeEquipWeaponID, error) {
	out := new(SCChangeEquipWeaponID)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqChangeEquipWeaponID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqChangeHandWeapon(ctx context.Context, in *CSChangeHandWeapon, opts ...grpc.CallOption) (*SCChangeHandWeapon, error) {
	out := new(SCChangeHandWeapon)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqChangeHandWeapon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqChangeWeaponPart(ctx context.Context, in *CSChangeWeaponPart, opts ...grpc.CallOption) (*SCChangeWeaponPart, error) {
	out := new(SCChangeWeaponPart)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqChangeWeaponPart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqUpgradeWeaponPart(ctx context.Context, in *CSUpgradeWeaponPart, opts ...grpc.CallOption) (*SCUpgradeWeaponPart, error) {
	out := new(SCUpgradeWeaponPart)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqUpgradeWeaponPart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqWeaponReload(ctx context.Context, in *CSWeaponReload, opts ...grpc.CallOption) (*SCWeaponReload, error) {
	out := new(SCWeaponReload)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqWeaponReload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqAimMove(ctx context.Context, in *CSAimMove, opts ...grpc.CallOption) (*SCAimMove, error) {
	out := new(SCAimMove)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqAimMove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqAttackNull(ctx context.Context, in *CSAttackNull, opts ...grpc.CallOption) (*SCAttackNull, error) {
	out := new(SCAttackNull)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqAttackNull", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqChangeRatio(ctx context.Context, in *CSChangeRatio, opts ...grpc.CallOption) (*SCChangeRatio, error) {
	out := new(SCChangeRatio)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqChangeRatio", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqEnterTable(ctx context.Context, in *CSEnterTable, opts ...grpc.CallOption) (*SCEnterTable, error) {
	out := new(SCEnterTable)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqEnterTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqLeaveTable(ctx context.Context, in *CSLeaveTable, opts ...grpc.CallOption) (*SCLeaveTable, error) {
	out := new(SCLeaveTable)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqLeaveTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqUseSkill(ctx context.Context, in *CSUseSkill, opts ...grpc.CallOption) (*SCUseSkill, error) {
	out := new(SCUseSkill)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqUseSkill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqHurtPlayer(ctx context.Context, in *CSHurtPlayer, opts ...grpc.CallOption) (*SCHurtPlayer, error) {
	out := new(SCHurtPlayer)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqHurtPlayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *biohouseClient) ReqPlayerHPChange(ctx context.Context, in *CSPlayerHPChange, opts ...grpc.CallOption) (*SCPlayerHPChange, error) {
	out := new(SCPlayerHPChange)
	err := c.cc.Invoke(ctx, "/biohouse.Biohouse/ReqPlayerHPChange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BiohouseServer is the server API for Biohouse service.
type BiohouseServer interface {
	ReqPing(context.Context, *CSPing) (*SCPing, error)
	ReqLogin(context.Context, *CSLogin) (*SCLogin, error)
	ReqLogout(context.Context, *CSLogout) (*SCLogout, error)
	ReqAttack(context.Context, *CSAttack) (*SCAttack, error)
	ReqMaterial(context.Context, *CSMaterial) (*SCMaterial, error)
	ReqChangeEquipWeaponID(context.Context, *CSChangeEquipWeaponID) (*SCChangeEquipWeaponID, error)
	ReqChangeHandWeapon(context.Context, *CSChangeHandWeapon) (*SCChangeHandWeapon, error)
	ReqChangeWeaponPart(context.Context, *CSChangeWeaponPart) (*SCChangeWeaponPart, error)
	ReqUpgradeWeaponPart(context.Context, *CSUpgradeWeaponPart) (*SCUpgradeWeaponPart, error)
	ReqWeaponReload(context.Context, *CSWeaponReload) (*SCWeaponReload, error)
	ReqAimMove(context.Context, *CSAimMove) (*SCAimMove, error)
	ReqAttackNull(context.Context, *CSAttackNull) (*SCAttackNull, error)
	ReqChangeRatio(context.Context, *CSChangeRatio) (*SCChangeRatio, error)
	ReqEnterTable(context.Context, *CSEnterTable) (*SCEnterTable, error)
	ReqLeaveTable(context.Context, *CSLeaveTable) (*SCLeaveTable, error)
	ReqUseSkill(context.Context, *CSUseSkill) (*SCUseSkill, error)
	ReqHurtPlayer(context.Context, *CSHurtPlayer) (*SCHurtPlayer, error)
	ReqPlayerHPChange(context.Context, *CSPlayerHPChange) (*SCPlayerHPChange, error)
}

// UnimplementedBiohouseServer can be embedded to have forward compatible implementations.
type UnimplementedBiohouseServer struct {
}

func (*UnimplementedBiohouseServer) ReqPing(ctx context.Context, req *CSPing) (*SCPing, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqPing not implemented")
}
func (*UnimplementedBiohouseServer) ReqLogin(ctx context.Context, req *CSLogin) (*SCLogin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqLogin not implemented")
}
func (*UnimplementedBiohouseServer) ReqLogout(ctx context.Context, req *CSLogout) (*SCLogout, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqLogout not implemented")
}
func (*UnimplementedBiohouseServer) ReqAttack(ctx context.Context, req *CSAttack) (*SCAttack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqAttack not implemented")
}
func (*UnimplementedBiohouseServer) ReqMaterial(ctx context.Context, req *CSMaterial) (*SCMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqMaterial not implemented")
}
func (*UnimplementedBiohouseServer) ReqChangeEquipWeaponID(ctx context.Context, req *CSChangeEquipWeaponID) (*SCChangeEquipWeaponID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqChangeEquipWeaponID not implemented")
}
func (*UnimplementedBiohouseServer) ReqChangeHandWeapon(ctx context.Context, req *CSChangeHandWeapon) (*SCChangeHandWeapon, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqChangeHandWeapon not implemented")
}
func (*UnimplementedBiohouseServer) ReqChangeWeaponPart(ctx context.Context, req *CSChangeWeaponPart) (*SCChangeWeaponPart, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqChangeWeaponPart not implemented")
}
func (*UnimplementedBiohouseServer) ReqUpgradeWeaponPart(ctx context.Context, req *CSUpgradeWeaponPart) (*SCUpgradeWeaponPart, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqUpgradeWeaponPart not implemented")
}
func (*UnimplementedBiohouseServer) ReqWeaponReload(ctx context.Context, req *CSWeaponReload) (*SCWeaponReload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqWeaponReload not implemented")
}
func (*UnimplementedBiohouseServer) ReqAimMove(ctx context.Context, req *CSAimMove) (*SCAimMove, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqAimMove not implemented")
}
func (*UnimplementedBiohouseServer) ReqAttackNull(ctx context.Context, req *CSAttackNull) (*SCAttackNull, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqAttackNull not implemented")
}
func (*UnimplementedBiohouseServer) ReqChangeRatio(ctx context.Context, req *CSChangeRatio) (*SCChangeRatio, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqChangeRatio not implemented")
}
func (*UnimplementedBiohouseServer) ReqEnterTable(ctx context.Context, req *CSEnterTable) (*SCEnterTable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqEnterTable not implemented")
}
func (*UnimplementedBiohouseServer) ReqLeaveTable(ctx context.Context, req *CSLeaveTable) (*SCLeaveTable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqLeaveTable not implemented")
}
func (*UnimplementedBiohouseServer) ReqUseSkill(ctx context.Context, req *CSUseSkill) (*SCUseSkill, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqUseSkill not implemented")
}
func (*UnimplementedBiohouseServer) ReqHurtPlayer(ctx context.Context, req *CSHurtPlayer) (*SCHurtPlayer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqHurtPlayer not implemented")
}
func (*UnimplementedBiohouseServer) ReqPlayerHPChange(ctx context.Context, req *CSPlayerHPChange) (*SCPlayerHPChange, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqPlayerHPChange not implemented")
}

func RegisterBiohouseServer(s *grpc.Server, srv BiohouseServer) {
	s.RegisterService(&_Biohouse_serviceDesc, srv)
}

func _Biohouse_ReqPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSPing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqPing(ctx, req.(*CSPing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSLogin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqLogin(ctx, req.(*CSLogin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSLogout)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqLogout(ctx, req.(*CSLogout))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqAttack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSAttack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqAttack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqAttack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqAttack(ctx, req.(*CSAttack))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSMaterial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqMaterial(ctx, req.(*CSMaterial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqChangeEquipWeaponID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSChangeEquipWeaponID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqChangeEquipWeaponID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqChangeEquipWeaponID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqChangeEquipWeaponID(ctx, req.(*CSChangeEquipWeaponID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqChangeHandWeapon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSChangeHandWeapon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqChangeHandWeapon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqChangeHandWeapon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqChangeHandWeapon(ctx, req.(*CSChangeHandWeapon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqChangeWeaponPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSChangeWeaponPart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqChangeWeaponPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqChangeWeaponPart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqChangeWeaponPart(ctx, req.(*CSChangeWeaponPart))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqUpgradeWeaponPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSUpgradeWeaponPart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqUpgradeWeaponPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqUpgradeWeaponPart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqUpgradeWeaponPart(ctx, req.(*CSUpgradeWeaponPart))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqWeaponReload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSWeaponReload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqWeaponReload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqWeaponReload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqWeaponReload(ctx, req.(*CSWeaponReload))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqAimMove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSAimMove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqAimMove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqAimMove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqAimMove(ctx, req.(*CSAimMove))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqAttackNull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSAttackNull)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqAttackNull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqAttackNull",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqAttackNull(ctx, req.(*CSAttackNull))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqChangeRatio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSChangeRatio)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqChangeRatio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqChangeRatio",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqChangeRatio(ctx, req.(*CSChangeRatio))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqEnterTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSEnterTable)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqEnterTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqEnterTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqEnterTable(ctx, req.(*CSEnterTable))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqLeaveTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSLeaveTable)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqLeaveTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqLeaveTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqLeaveTable(ctx, req.(*CSLeaveTable))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqUseSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSUseSkill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqUseSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqUseSkill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqUseSkill(ctx, req.(*CSUseSkill))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqHurtPlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSHurtPlayer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqHurtPlayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqHurtPlayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqHurtPlayer(ctx, req.(*CSHurtPlayer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Biohouse_ReqPlayerHPChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSPlayerHPChange)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BiohouseServer).ReqPlayerHPChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/biohouse.Biohouse/ReqPlayerHPChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BiohouseServer).ReqPlayerHPChange(ctx, req.(*CSPlayerHPChange))
	}
	return interceptor(ctx, in, info, handler)
}

var _Biohouse_serviceDesc = grpc.ServiceDesc{
	ServiceName: "biohouse.Biohouse",
	HandlerType: (*BiohouseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReqPing",
			Handler:    _Biohouse_ReqPing_Handler,
		},
		{
			MethodName: "ReqLogin",
			Handler:    _Biohouse_ReqLogin_Handler,
		},
		{
			MethodName: "ReqLogout",
			Handler:    _Biohouse_ReqLogout_Handler,
		},
		{
			MethodName: "ReqAttack",
			Handler:    _Biohouse_ReqAttack_Handler,
		},
		{
			MethodName: "ReqMaterial",
			Handler:    _Biohouse_ReqMaterial_Handler,
		},
		{
			MethodName: "ReqChangeEquipWeaponID",
			Handler:    _Biohouse_ReqChangeEquipWeaponID_Handler,
		},
		{
			MethodName: "ReqChangeHandWeapon",
			Handler:    _Biohouse_ReqChangeHandWeapon_Handler,
		},
		{
			MethodName: "ReqChangeWeaponPart",
			Handler:    _Biohouse_ReqChangeWeaponPart_Handler,
		},
		{
			MethodName: "ReqUpgradeWeaponPart",
			Handler:    _Biohouse_ReqUpgradeWeaponPart_Handler,
		},
		{
			MethodName: "ReqWeaponReload",
			Handler:    _Biohouse_ReqWeaponReload_Handler,
		},
		{
			MethodName: "ReqAimMove",
			Handler:    _Biohouse_ReqAimMove_Handler,
		},
		{
			MethodName: "ReqAttackNull",
			Handler:    _Biohouse_ReqAttackNull_Handler,
		},
		{
			MethodName: "ReqChangeRatio",
			Handler:    _Biohouse_ReqChangeRatio_Handler,
		},
		{
			MethodName: "ReqEnterTable",
			Handler:    _Biohouse_ReqEnterTable_Handler,
		},
		{
			MethodName: "ReqLeaveTable",
			Handler:    _Biohouse_ReqLeaveTable_Handler,
		},
		{
			MethodName: "ReqUseSkill",
			Handler:    _Biohouse_ReqUseSkill_Handler,
		},
		{
			MethodName: "ReqHurtPlayer",
			Handler:    _Biohouse_ReqHurtPlayer_Handler,
		},
		{
			MethodName: "ReqPlayerHPChange",
			Handler:    _Biohouse_ReqPlayerHPChange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "biohouse.proto",
}

func (m *CSPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurSec != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CurSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeaponInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeaponInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeaponInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EquipPart != nil {
		i -= len(*m.EquipPart)
		copy(dAtA[i:], *m.EquipPart)
		i = encodeVarintBiohouse(dAtA, i, uint64(len(*m.EquipPart)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Token != nil {
		i -= len(*m.Token)
		copy(dAtA[i:], *m.Token)
		i = encodeVarintBiohouse(dAtA, i, uint64(len(*m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.HandID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.HandID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EquipID) > 0 {
		for iNdEx := len(m.EquipID) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintBiohouse(dAtA, i, uint64(m.EquipID[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Money != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Money))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSLogout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSLogout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCLogout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCLogout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogoutType != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.LogoutType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TablePlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TablePlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TablePlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Blood != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Blood))
		i--
		dAtA[i] = 0x60
	}
	if m.Ratio != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Ratio))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.EquipID) > 0 {
		for iNdEx := len(m.EquipID) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintBiohouse(dAtA, i, uint64(m.EquipID[iNdEx]))
			i--
			dAtA[i] = 0x48
		}
	}
	if m.HandID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.HandID))
		i--
		dAtA[i] = 0x40
	}
	if m.Nick != nil {
		i -= len(*m.Nick)
		copy(dAtA[i:], *m.Nick)
		i = encodeVarintBiohouse(dAtA, i, uint64(len(*m.Nick)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Portrait != nil {
		i -= len(*m.Portrait)
		copy(dAtA[i:], *m.Portrait)
		i = encodeVarintBiohouse(dAtA, i, uint64(len(*m.Portrait)))
		i--
		dAtA[i] = 0x32
	}
	if m.Background != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Background))
		i--
		dAtA[i] = 0x28
	}
	if m.VipLevel != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.VipLevel))
		i--
		dAtA[i] = 0x20
	}
	if m.ChairId != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.ChairId))
		i--
		dAtA[i] = 0x18
	}
	if m.Money != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSEnterTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSEnterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSEnterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCEnterTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCEnterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCEnterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.TableID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSLeaveTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSLeaveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSLeaveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCLeaveTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCLeaveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCLeaveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCMoney) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCMoney) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCMoney) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Money != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSAttack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSAttack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSAttack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PartID))
		i--
		dAtA[i] = 0x10
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BloodLeft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BloodLeft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BloodLeft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeftBlood != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.LeftBlood))
		i--
		dAtA[i] = 0x10
	}
	if m.PartType != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PartType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCAttack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCAttack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCAttack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Clip != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Clip))
		i--
		dAtA[i] = 0x30
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LeftBlood != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.LeftBlood))
		i--
		dAtA[i] = 0x20
	}
	if m.Money != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Money))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCVipLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCVipLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCVipLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VipLevel != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.VipLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeNum != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.ChangeNum))
		i--
		dAtA[i] = 0x18
	}
	if m.PropsNum != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PropsNum))
		i--
		dAtA[i] = 0x10
	}
	if m.PropsID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PropsID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCPropsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCPropsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCPropsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSUseSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSUseSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSUseSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Use != nil {
		i--
		if *m.Use {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SkillID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.SkillID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCUseSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCUseSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCUseSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x18
	}
	if m.Use != nil {
		i--
		if *m.Use {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SkillID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.SkillID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PointInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Z))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Y != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Y))))
		i--
		dAtA[i] = 0x15
	}
	if m.X != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.X))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *MonsterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonsterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonsterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AIType != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.AIType))
		i--
		dAtA[i] = 0x40
	}
	if m.EndTime != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.EndTime))
		i--
		dAtA[i] = 0x38
	}
	if m.BeginTime != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.BeginTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Left) > 0 {
		for iNdEx := len(m.Left) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Left[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Point) > 0 {
		for iNdEx := len(m.Point) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Point[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MonsterID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.MonsterID))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x10
	}
	if m.LineType != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.LineType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCNewMonster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCNewMonster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCNewMonster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		for iNdEx := len(m.Info) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Info[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaterialInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterialInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaterialInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Num))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSMaterial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSMaterial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSMaterial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCMaterial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCMaterial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCMaterial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MatInfo) > 0 {
		for iNdEx := len(m.MatInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SCChangeMaterial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCChangeMaterial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCChangeMaterial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MatInfo) > 0 {
		for iNdEx := len(m.MatInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSChangeEquipWeaponID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSChangeEquipWeaponID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSChangeEquipWeaponID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EquipID) > 0 {
		for iNdEx := len(m.EquipID) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintBiohouse(dAtA, i, uint64(m.EquipID[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *SCChangeEquipWeaponID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCChangeEquipWeaponID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCChangeEquipWeaponID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CSChangeHandWeapon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSChangeHandWeapon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSChangeHandWeapon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HandID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.HandID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCChangeHandWeapon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCChangeHandWeapon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCChangeHandWeapon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ratio != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Ratio))
		i--
		dAtA[i] = 0x18
	}
	if m.HandID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.HandID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSChangeWeaponPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSChangeWeaponPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSChangeWeaponPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Quality != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Quality))
		i--
		dAtA[i] = 0x18
	}
	if m.PartID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PartID))
		i--
		dAtA[i] = 0x10
	}
	if m.WeaponID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.WeaponID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCChangeWeaponPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCChangeWeaponPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCChangeWeaponPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CSUpgradeWeaponPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSUpgradeWeaponPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSUpgradeWeaponPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PartID))
		i--
		dAtA[i] = 0x10
	}
	if m.WeaponID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.WeaponID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCUpgradeWeaponPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCUpgradeWeaponPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCUpgradeWeaponPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CSChangeRatio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSChangeRatio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSChangeRatio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ratio != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Ratio))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCChangeRatio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCChangeRatio) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCChangeRatio) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ratio != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Ratio))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSWeaponReload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSWeaponReload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSWeaponReload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SCWeaponReload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCWeaponReload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCWeaponReload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSAimMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSAimMove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSAimMove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Point != nil {
		{
			size, err := m.Point.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SCAimMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCAimMove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCAimMove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Point != nil {
		{
			size, err := m.Point.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSAttackNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSAttackNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSAttackNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Point != nil {
		{
			size, err := m.Point.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SCAttackNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCAttackNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCAttackNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Point != nil {
		{
			size, err := m.Point.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCPassLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCPassLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCPassLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PathID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PathID))
		i--
		dAtA[i] = 0x28
	}
	if m.Node != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Node))
		i--
		dAtA[i] = 0x20
	}
	if m.MapID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.MapID))
		i--
		dAtA[i] = 0x18
	}
	if m.NewPass != nil {
		i--
		if *m.NewPass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Success != nil {
		i--
		if *m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HurtBlood) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HurtBlood) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HurtBlood) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Blood != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Blood))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HurtPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HurtPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HurtPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hurt) > 0 {
		for iNdEx := len(m.Hurt) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hurt[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerBlood) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerBlood) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerBlood) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasDied != nil {
		i--
		if *m.HasDied {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Blood != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Blood))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCMonsterAttackPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCMonsterAttackPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCMonsterAttackPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Left) > 0 {
		for iNdEx := len(m.Left) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Left[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hp) > 0 {
		for iNdEx := len(m.Hp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SCRecoveryPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCRecoveryPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCRecoveryPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Left) > 0 {
		for iNdEx := len(m.Left) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Left[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBiohouse(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SCCurLevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCurLevelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCurLevelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stamp != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Stamp))
		i--
		dAtA[i] = 0x20
	}
	if m.Node != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.Node))
		i--
		dAtA[i] = 0x18
	}
	if m.PathID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PathID))
		i--
		dAtA[i] = 0x10
	}
	if m.MapID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.MapID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerHP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerHP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerHP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeftHP != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.LeftHP))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSHurtPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSHurtPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSHurtPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PH != nil {
		{
			size, err := m.PH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCHurtPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCHurtPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCHurtPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PH != nil {
		{
			size, err := m.PH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreateID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.CreateID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != nil {
		i = encodeVarintBiohouse(dAtA, i, uint64(*m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSPlayerHPChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSPlayerHPChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSPlayerHPChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PH != nil {
		{
			size, err := m.PH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SCPlayerHPChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCPlayerHPChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCPlayerHPChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PH != nil {
		{
			size, err := m.PH.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBiohouse(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBiohouse(dAtA []byte, offset int, v uint64) int {
	offset -= sovBiohouse(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CSPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurSec != nil {
		n += 1 + sovBiohouse(uint64(*m.CurSec))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WeaponInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += 1 + sovBiohouse(uint64(*m.ID))
	}
	if m.EquipPart != nil {
		l = len(*m.EquipPart)
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Token != nil {
		l = len(*m.Token)
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovBiohouse(uint64(*m.Version))
	}
	if m.Mode != nil {
		n += 1 + sovBiohouse(uint64(*m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Money != nil {
		n += 1 + sovBiohouse(uint64(*m.Money))
	}
	if len(m.EquipID) > 0 {
		for _, e := range m.EquipID {
			n += 1 + sovBiohouse(uint64(e))
		}
	}
	if m.HandID != nil {
		n += 1 + sovBiohouse(uint64(*m.HandID))
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSLogout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCLogout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogoutType != nil {
		n += 1 + sovBiohouse(uint64(*m.LogoutType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TablePlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Money != nil {
		n += 1 + sovBiohouse(uint64(*m.Money))
	}
	if m.ChairId != nil {
		n += 1 + sovBiohouse(uint64(*m.ChairId))
	}
	if m.VipLevel != nil {
		n += 1 + sovBiohouse(uint64(*m.VipLevel))
	}
	if m.Background != nil {
		n += 1 + sovBiohouse(uint64(*m.Background))
	}
	if m.Portrait != nil {
		l = len(*m.Portrait)
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.Nick != nil {
		l = len(*m.Nick)
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.HandID != nil {
		n += 1 + sovBiohouse(uint64(*m.HandID))
	}
	if len(m.EquipID) > 0 {
		for _, e := range m.EquipID {
			n += 1 + sovBiohouse(uint64(e))
		}
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.Ratio != nil {
		n += 1 + sovBiohouse(uint64(*m.Ratio))
	}
	if m.Blood != nil {
		n += 1 + sovBiohouse(uint64(*m.Blood))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSEnterTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != nil {
		n += 1 + sovBiohouse(uint64(*m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCEnterTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.TableID != nil {
		n += 1 + sovBiohouse(uint64(*m.TableID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSLeaveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCLeaveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCMoney) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Money != nil {
		n += 1 + sovBiohouse(uint64(*m.Money))
	}
	if m.Type != nil {
		n += 1 + sovBiohouse(uint64(*m.Type))
	}
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSAttack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.PartID != nil {
		n += 1 + sovBiohouse(uint64(*m.PartID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BloodLeft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartType != nil {
		n += 1 + sovBiohouse(uint64(*m.PartType))
	}
	if m.LeftBlood != nil {
		n += 1 + sovBiohouse(uint64(*m.LeftBlood))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCAttack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.Money != nil {
		n += 1 + sovBiohouse(uint64(*m.Money))
	}
	if m.LeftBlood != nil {
		n += 1 + sovBiohouse(uint64(*m.LeftBlood))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.Clip != nil {
		n += 1 + sovBiohouse(uint64(*m.Clip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCVipLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.VipLevel != nil {
		n += 1 + sovBiohouse(uint64(*m.VipLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PropsID != nil {
		n += 1 + sovBiohouse(uint64(*m.PropsID))
	}
	if m.PropsNum != nil {
		n += 1 + sovBiohouse(uint64(*m.PropsNum))
	}
	if m.ChangeNum != nil {
		n += 1 + sovBiohouse(uint64(*m.ChangeNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCPropsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSUseSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkillID != nil {
		n += 1 + sovBiohouse(uint64(*m.SkillID))
	}
	if m.Use != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCUseSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkillID != nil {
		n += 1 + sovBiohouse(uint64(*m.SkillID))
	}
	if m.Use != nil {
		n += 2
	}
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PointInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 5
	}
	if m.Y != nil {
		n += 5
	}
	if m.Z != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonsterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LineType != nil {
		n += 1 + sovBiohouse(uint64(*m.LineType))
	}
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.MonsterID != nil {
		n += 1 + sovBiohouse(uint64(*m.MonsterID))
	}
	if len(m.Point) > 0 {
		for _, e := range m.Point {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if len(m.Left) > 0 {
		for _, e := range m.Left {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.BeginTime != nil {
		n += 1 + sovBiohouse(uint64(*m.BeginTime))
	}
	if m.EndTime != nil {
		n += 1 + sovBiohouse(uint64(*m.EndTime))
	}
	if m.AIType != nil {
		n += 1 + sovBiohouse(uint64(*m.AIType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCNewMonster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaterialInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += 1 + sovBiohouse(uint64(*m.ID))
	}
	if m.Num != nil {
		n += 1 + sovBiohouse(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSMaterial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCMaterial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatInfo) > 0 {
		for _, e := range m.MatInfo {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCChangeMaterial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatInfo) > 0 {
		for _, e := range m.MatInfo {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.Type != nil {
		n += 1 + sovBiohouse(uint64(*m.Type))
	}
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSChangeEquipWeaponID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EquipID) > 0 {
		for _, e := range m.EquipID {
			n += 1 + sovBiohouse(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCChangeEquipWeaponID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSChangeHandWeapon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HandID != nil {
		n += 1 + sovBiohouse(uint64(*m.HandID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCChangeHandWeapon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.HandID != nil {
		n += 1 + sovBiohouse(uint64(*m.HandID))
	}
	if m.Ratio != nil {
		n += 1 + sovBiohouse(uint64(*m.Ratio))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSChangeWeaponPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WeaponID != nil {
		n += 1 + sovBiohouse(uint64(*m.WeaponID))
	}
	if m.PartID != nil {
		n += 1 + sovBiohouse(uint64(*m.PartID))
	}
	if m.Quality != nil {
		n += 1 + sovBiohouse(uint64(*m.Quality))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCChangeWeaponPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSUpgradeWeaponPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WeaponID != nil {
		n += 1 + sovBiohouse(uint64(*m.WeaponID))
	}
	if m.PartID != nil {
		n += 1 + sovBiohouse(uint64(*m.PartID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCUpgradeWeaponPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSChangeRatio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ratio != nil {
		n += 1 + sovBiohouse(uint64(*m.Ratio))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCChangeRatio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Ratio != nil {
		n += 1 + sovBiohouse(uint64(*m.Ratio))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSWeaponReload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCWeaponReload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSAimMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCAimMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSAttackNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCAttackNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCPassLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success != nil {
		n += 2
	}
	if m.NewPass != nil {
		n += 2
	}
	if m.MapID != nil {
		n += 1 + sovBiohouse(uint64(*m.MapID))
	}
	if m.Node != nil {
		n += 1 + sovBiohouse(uint64(*m.Node))
	}
	if m.PathID != nil {
		n += 1 + sovBiohouse(uint64(*m.PathID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HurtBlood) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Blood != nil {
		n += 1 + sovBiohouse(uint64(*m.Blood))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HurtPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if len(m.Hurt) > 0 {
		for _, e := range m.Hurt {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerBlood) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.Blood != nil {
		n += 1 + sovBiohouse(uint64(*m.Blood))
	}
	if m.HasDied != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCMonsterAttackPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hp) > 0 {
		for _, e := range m.Hp {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if len(m.Left) > 0 {
		for _, e := range m.Left {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCRecoveryPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Left) > 0 {
		for _, e := range m.Left {
			l = e.Size()
			n += 1 + l + sovBiohouse(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCCurLevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapID != nil {
		n += 1 + sovBiohouse(uint64(*m.MapID))
	}
	if m.PathID != nil {
		n += 1 + sovBiohouse(uint64(*m.PathID))
	}
	if m.Node != nil {
		n += 1 + sovBiohouse(uint64(*m.Node))
	}
	if m.Stamp != nil {
		n += 1 + sovBiohouse(uint64(*m.Stamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerHP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.LeftHP != nil {
		n += 1 + sovBiohouse(uint64(*m.LeftHP))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSHurtPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.PH != nil {
		l = m.PH.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCHurtPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != nil {
		n += 1 + sovBiohouse(uint64(*m.PlayerID))
	}
	if m.CreateID != nil {
		n += 1 + sovBiohouse(uint64(*m.CreateID))
	}
	if m.PH != nil {
		l = m.PH.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSPlayerHPChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PH != nil {
		l = m.PH.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SCPlayerHPChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PH != nil {
		l = m.PH.Size()
		n += 1 + l + sovBiohouse(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBiohouse(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBiohouse(x uint64) (n int) {
	return sovBiohouse(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CSPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurSec", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurSec = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeaponInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeaponInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeaponInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipPart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.EquipPart = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Token = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Money = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EquipID = append(m.EquipID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBiohouse
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBiohouse
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EquipID) == 0 {
					m.EquipID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBiohouse
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EquipID = append(m.EquipID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipID", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandID = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &WeaponInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoutType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogoutType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TablePlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TablePlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TablePlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Money = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChairId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChairId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VipLevel = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Background = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Portrait", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Portrait = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Nick = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandID = &v
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EquipID = append(m.EquipID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBiohouse
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBiohouse
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EquipID) == 0 {
					m.EquipID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBiohouse
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EquipID = append(m.EquipID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipID", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &WeaponInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ratio = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blood", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blood = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSEnterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSEnterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSEnterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCEnterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCEnterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCEnterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &TablePlayer{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSLeaveTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSLeaveTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSLeaveTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCLeaveTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCLeaveTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCLeaveTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCMoney) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCMoney: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCMoney: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Money = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSAttack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSAttack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSAttack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BloodLeft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BloodLeft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BloodLeft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftBlood", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftBlood = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCAttack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCAttack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCAttack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Money = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftBlood", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftBlood = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &BloodLeft{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clip", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clip = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCVipLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCVipLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCVipLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VipLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropsID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropsNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropsNum = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeNum = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCPropsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCPropsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCPropsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &PropsInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSUseSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSUseSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSUseSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkillID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Use = &b
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCUseSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCUseSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCUseSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkillID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Use = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.X = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Y = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Z = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonsterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonsterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonsterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LineType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MonsterID = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Point = append(m.Point, &PointInfo{})
			if err := m.Point[len(m.Point)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = append(m.Left, &BloodLeft{})
			if err := m.Left[len(m.Left)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BeginTime = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndTime = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AIType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AIType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCNewMonster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCNewMonster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCNewMonster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &MonsterInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterialInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterialInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Num = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSMaterial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSMaterial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSMaterial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCMaterial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCMaterial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCMaterial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatInfo = append(m.MatInfo, &MaterialInfo{})
			if err := m.MatInfo[len(m.MatInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCChangeMaterial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCChangeMaterial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCChangeMaterial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatInfo = append(m.MatInfo, &MaterialInfo{})
			if err := m.MatInfo[len(m.MatInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v MaterialType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MaterialType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSChangeEquipWeaponID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSChangeEquipWeaponID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSChangeEquipWeaponID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EquipID = append(m.EquipID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBiohouse
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBiohouse
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBiohouse
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EquipID) == 0 {
					m.EquipID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBiohouse
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EquipID = append(m.EquipID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCChangeEquipWeaponID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCChangeEquipWeaponID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCChangeEquipWeaponID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSChangeHandWeapon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSChangeHandWeapon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSChangeHandWeapon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCChangeHandWeapon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCChangeHandWeapon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCChangeHandWeapon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ratio = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSChangeWeaponPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSChangeWeaponPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSChangeWeaponPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WeaponID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quality = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCChangeWeaponPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCChangeWeaponPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCChangeWeaponPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &WeaponInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSUpgradeWeaponPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSUpgradeWeaponPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSUpgradeWeaponPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WeaponID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCUpgradeWeaponPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCUpgradeWeaponPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCUpgradeWeaponPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &WeaponInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSChangeRatio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSChangeRatio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSChangeRatio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ratio = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCChangeRatio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCChangeRatio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCChangeRatio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ratio = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSWeaponReload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSWeaponReload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSWeaponReload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCWeaponReload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCWeaponReload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCWeaponReload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSAimMove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSAimMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSAimMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &PointInfo{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCAimMove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCAimMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCAimMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &PointInfo{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSAttackNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSAttackNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSAttackNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &PointInfo{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCAttackNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCAttackNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCAttackNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &PointInfo{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCPassLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCPassLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCPassLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Success = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NewPass = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MapID = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Node = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PathID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HurtBlood) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HurtBlood: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HurtBlood: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blood", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blood = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HurtPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HurtPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HurtPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hurt = append(m.Hurt, &HurtBlood{})
			if err := m.Hurt[len(m.Hurt)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerBlood) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerBlood: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerBlood: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blood", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blood = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasDied", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HasDied = &b
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCMonsterAttackPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCMonsterAttackPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCMonsterAttackPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hp = append(m.Hp, &HurtPlayer{})
			if err := m.Hp[len(m.Hp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = append(m.Left, &PlayerBlood{})
			if err := m.Left[len(m.Left)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCRecoveryPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCRecoveryPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCRecoveryPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = append(m.Left, &PlayerBlood{})
			if err := m.Left[len(m.Left)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCurLevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCurLevelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCurLevelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MapID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PathID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Node = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stamp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerHP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerHP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerHP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftHP", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftHP = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSHurtPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSHurtPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSHurtPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PH == nil {
				m.PH = &PlayerHP{}
			}
			if err := m.PH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCHurtPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCHurtPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCHurtPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateID = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PH == nil {
				m.PH = &PlayerHP{}
			}
			if err := m.PH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSPlayerHPChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSPlayerHPChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSPlayerHPChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PH == nil {
				m.PH = &PlayerHP{}
			}
			if err := m.PH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCPlayerHPChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCPlayerHPChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCPlayerHPChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBiohouse
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBiohouse
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PH == nil {
				m.PH = &PlayerHP{}
			}
			if err := m.PH.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBiohouse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBiohouse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBiohouse(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBiohouse
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBiohouse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBiohouse
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBiohouse
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBiohouse
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBiohouse        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBiohouse          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBiohouse = fmt.Errorf("proto: unexpected end of group")
)
